<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>５．アルゴリズム研究</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>５０１．テンプレートメソッドを使った敵キャラの構造</h3>
<br />
<h4>テンプレートメソッドとは</h4>
　<b>テンプレートメソッド</b>は<b>デザインパターン</b>に含まれるパターンの1つで、継承関係にあるオブジェクト操作の1つです。<br />
　たとえば、以下のような継承関係があったとします。
<p>&nbsp;</p>
<img src="img/5001a.jpg" width="80%"/>
<p>図5001a</p>
<p>&nbsp;</p>
　外部から（たとえばステートから）、このオブジェクトの<b>FuncMotion()関数</b>を呼び出します。<br />
　この継承関係には、親クラスである<b>EnemyBaseクラス</b>には、純粋仮想関数<b>FuncMethod()関数</b>があり、この仮想関数を<b>親クラスが呼び出し</b>ます。<br />
　すると、各派生クラスの仮想関数が呼び出されます。<br />
<br />
　この例だけでは<b>テンプレートメソッド</b>の魅力は十分に伝わらないかもしれません。なぜなら、親クラスの<b>FuncMotion()関数</b>の存在意義がわかりません。<b>外部から直接FuncMethod()関数を呼び出せ</b>ばいいのかと思ってしまいます。<br />
<br/>
　しかし、以下の構造を見てください。
<p>&nbsp;</p>
<img src="img/5001b.jpg" width="80%"/>
<p>図5001b</p>
<p>&nbsp;</p>
　この構造では、<b>親クラスが呼び出す仮想関数が2つ（以上）</b>あります。つまり、どの仮想関数を呼び出すか、親クラス側に選択権が出てきます。もちろん、ここで仮想関数以外を呼び出しても問題はありません。<br />
　ポイントは、<b>親クラスのFuncMotion()関数では様々な処理が可能</b>だということです。<br />
　このことにより、階層外の（つまり外部の）クラスには、親クラスの<b>FuncMotion()関数</b>のみ公開しておけばよくなり、<b>FuncMethod()関数やFuncMethod2()関数は、protected</b>で記述可能です。（実は、これはC++特有ですが、<b>FuncMethod()関数やFuncMethod2()関数は、private</b>でも記述可能なのです！）この場合、protectedとprivateの恩恵の差は、あまり思いつきませんが、いずれにせよ、仮想関数を外部から隠ぺい（階層内で閉じる）ように記述できるのです。<br />
<br />
　このことは、チーム制作上でも、ソースの保守に大いに役立ちます。<br />
　あるクラス階層（敵キャラ、アイテム、障害物などいろんなオブジェクトを階層化できます）を記述するプログラマは、何かのイベント、あるいは関数呼び出しなどを受ける場合、親クラスにある、<b>FuncMotion()関数のような関数</b>を公開すればよいことになります。外部からはこれが、仮想関数呼び出しを行っているのか、あるいは、呼び出してないのか、など、知る必要はありません。呼び出す側は、<b>何かのタイミングで、FuncMotion()関数を呼び出せばよい</b>という設計にすることができます。<br />
<br />
<h4>テンプレートメソッドの実装</h4>
　このサンプル（<b>Sample501</b>）を実行すると以下のような画面が出てきます。<br />
　サンプル106と似てますが、実装方法が違います。こちらはテンプレートメソッドを使用しています。<br />
<p>&nbsp;</p>
<img src="img/5001c.jpg" width="80%"/>
<p>図5001c</p>
<p>&nbsp;</p>
　サンプルの構造は、<b>図5001a</b>に近い形ですが、回転するトーラスと色が変わる正8面体が共通の親クラスを持ち、親クラスから仮想関数呼び出しを行ってます。<br />
　具体的には<b>Charactor.h、cpp</b>に記述があります。<br />
　以下はヘッダの親クラス宣言です。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class Enemy : public GameObject;
    //  用途: 敵キャラの親クラス
    //--------------------------------------------------------------------------------------
    class Enemy : public GameObject{
        shared_ptr&lt; StateMachine&lt;Enemy> >  m_StateMachine;    //ステートマシーン

        //中略

    protected:

        //中略

        <span class="red">//派生クラスは、必ずこの仮想関数を実装する
        virtual void ExtMotionMethod() = 0;
        virtual void ShellHitMotionMethod() = 0;</span>

    public:

        //中略

        <span class="red">//この関数はメソッド呼び出し関数として実装する
        void ExtMotion();
        //砲弾と衝突した瞬間の処理
        void ShellHitMotion();</span>

        //中略
    };
</pre>
</div>
　この階層の特徴は、<b>ステートは親側(つまりEnemyクラス)</b>で管理するということです。<br />
　そして、ステートから、公開関数である<b>ExtMotion()関数</b>を呼び出します。<br />
　純粋仮想関数<b>virtual void ExtMotionMethod()とvirtual void ShellHitMotionMethod()</b>は、<b>protected関数</b>です。
<br />
　以下が派生クラスの宣言です、トーラスを例にとってます。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class RollingTorus : public Enemy;
    //  用途: 回転するトーラス
    //--------------------------------------------------------------------------------------
    class RollingTorus : public Enemy{

        //中略

    protected:
        <span class="red">//派生クラスは、必ずこの仮想関数を実装する
        virtual void ExtMotionMethod()override;
        virtual void ShellHitMotionMethod()override;</span>
    public:

        //中略

    };
</pre>
</div>
　以下がトーラスクラスの、<b>ExtMotionMethod()</b>の実体です。
<div class="box1">
<pre>
    //派生クラスは、必ずこの仮想関数を実装する
    void RollingTorus::ExtMotionMethod(){
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        m_YRot += (m_RotationSpeed * ElapsedTime);
        if (m_RotationSpeed > 0){
            m_RotationSpeed -= 0.05f;
        }
        auto Ptr = GetComponent&lt;Transform>();
        Ptr->SetRotation(XM_PIDIV2, m_YRot, 0.0f);
    }
</pre>
</div>
　こんな感じで、すべての派生クラスで、純粋仮想関数を多重定義します。<br />
<br />
　そして以下が、実際に仮想関数を呼び出すところです。
<div class="box1">
<pre>
    //この関数はメソッド呼び出し関数として実装する
    void Enemy::ExtMotion(){
        //仮想関数呼び出し
        //この呼び出しで派生クラスの仮想関数が実行される
        ExtMotionMethod();
    }
    //砲弾と衝突した瞬間の処理
    void Enemy::ShellHitMotion(){
        //仮想関数呼び出し
        //この呼び出しで派生クラスの仮想関数が実行される
        ShellHitMotionMethod();
    }
</pre>
</div>
<br />
　最後に、<b>ExtMotion()やShellHitMotion()</b>を呼び出す箇所は、ステートの中になります。<br />
　たとえば<b>Enemy::ExtMotion()</b>は、以下のように、<b>EnemyDefaultState::Execute()関数</b>などで呼ばれます。
<div class="box1">
<pre>
    //ステート実行中に毎ターン呼ばれる関数
    void EnemyDefaultState::Execute(const shared_ptr&lt;Enemy>& Obj){
        <span class="red">Obj->ExtMotion();</span>
        Obj->ShellThrowMotion();
    }
</pre>
</div>
<br />
　このように、<b>テンプレートメソッド</b>は汎用性も高く、ステートと一緒に使用しても問題ありません。<br />
　ぜひ、使用してみましょう。
<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="index.html">目次</a></li>
<li><a href="50_02.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
