<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．チュートリアル</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>００５．衝突判定と自動反発</h3>
<br />
<h4>自動反発</h4>
　Tutorial005のソリューションを開いてリビルド、実行すると以下のような画面になります（コントローラで少し引いた画面です）。<br />
　ここでは4つのオブジェクト（球体二つとボックス2つ）がお互いに反発しあいながら運動を繰り返してます。<br />
<p>&nbsp;</p>
<img src="img/0005a.jpg" width="80%"/>
<p>図0005a</p>
<p>&nbsp;</p>
　今回作成するクラスは、<b>MoveObjectクラス</b>です。<b>Character.hとCharacter.cpp</b>に記述があります。<br/>
<br />
<h4>Rigidbodyコンポーネント</h4>
　衝突判定に自動反発をつけるためには<b>Rigidbodyコンポーネント</b>を使用します。<br />
　まず<b>Character.h</b>に<b>MoveObjectクラス</b>の宣言を記述します。
<br />
<div class="box1">
<pre>
//--------------------------------------------------------------------------------------
//  class MoveObject : public GameObject;
//  用途: 動くオブジェクト
//--------------------------------------------------------------------------------------
class MoveObject : public GameObject{
    Vector3 m_StartPos;
    Vector3 m_StartVelocity;
    bool m_Type;
public:
    //構築と破棄
    MoveObject(const shared_ptr&lt;Stage>& StagePtr, 
        const Vector3& StartPos, const Vector3& StartVelocity, bool Type);
    virtual ~MoveObject();
    //初期化
    virtual void Create() override;
    //更新
    virtual void Update2() override;
};
</pre>
</div>
　このように、<b>void Create()仮想関数とvoid Update2()仮想関数</b>を多重定義して実装します。<br />
<br />
　配置されるのは<b>MoveObjectクラス</b>ですが、球体もボックスも同じクラスを使います。球体かボックスかを区別つけるために、コンストラクタに<b>bool Type</b>という引数を設けます。<b>true</b>なら球体、<b>false</b>ならボックスです。<br />
　以下が、<b>Character.cpp</b>にある<b>void MoveObject::Create()関数</b>の実体です。
<div class="box1">
<pre>
//初期化
void MoveObject::Create(){
    auto PtrTransform = GetComponent&lt;Transform>();
    PtrTransform->SetScale(1.0f, 1.0f, 1.0f);
    PtrTransform->SetRotation(0.0f, 0.0f, 0.0f);
    PtrTransform->SetPosition(m_StartPos);
    <span class="red">if (m_Type){
        //Sphereの衝突判定をつける
        auto PtrSphere = AddComponent&lt;CollisionSphere>();
    }
    else{
        //OBBの衝突判定をつける
        auto PtrObb = AddComponent&lt;CollisionObb>();
    }</span>

    //物理計算をつける
    <span class="red">auto PtrRigit = AddComponent&lt;Rigidbody>();
    PtrRigit->SetVelocity(m_StartVelocity);</span>
    //影をつける
    auto ShadowPtr = AddComponent&lt;Shadowmap>();
    if (m_Type){
        ShadowPtr->SetMeshResource(L"DEFAULT_SPHERE");
    }
    else{
        ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");
    }
    auto PtrDraw = AddComponent&lt;BasicPNTDraw>();
    if (m_Type){
        PtrDraw->SetMeshResource(L"DEFAULT_SPHERE");
    }
    else{
        PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
    }
    PtrDraw->SetTextureResource(L"TRACE_TX");
    //透明有効
    SetAlphaActive(true);
}
</pre>
</div>
　赤くなっているところがポイントです。衝突判定は、形状が違いますので、球体とボックスで、追加するコンポーネントを変えています。<br />
<div class="box1">
<pre>
    //物理計算をつける
    <span class="red">auto PtrRigit = AddComponent&lt;Rigidbody>();
    PtrRigit->SetVelocity(m_StartVelocity);</span>
</pre>
</div>
　上記2行で自動反発するようになります。<br />
　<b>Rigidbodyコンポーネント</b>を追加した場合は、<b>TransformコンポーネントのPosition</b>は通常は直接変更しません。（回転は変更することがあります）<br />
　これは大変重要なことです。<b>Rigidbodyコンポーネント</b>は内部に、速度、反発係数や質量を持っていて、衝突相手の質量や速度を加味しながら、自身の反発方向と速度を計算します。<br />
　<b>Rigidbodyコンポーネント</b>を追加した場合、変更するのは<b>速度</b>です。ここでは、スタート時の初速度のみ設定しています。<br />
　<b>PtrRigit->SetVelocity(m_StartVelocity);</b>が初速度を設定する設定です。<br/>
<br />
　続いて、<b>Update2()関数</b>です。
<div class="box1">
<pre>
//更新
void MoveObject::Update2(){
    auto PtrRigit = GetComponent&lt;Rigidbody>();
    auto Velo = PtrRigit->GetVelocity();
    //自動反発で速度yが０以外になる場合があるので調整
    Velo.y = 0;
    PtrRigit->SetVelocity(Velo);
}
</pre>
</div>
　ここでは、自動反発によって速度のY値がずれる可能性があるので調整しています。つまり、反発は3次元方向に向かうので、平面上でまっすぐ衝突しても、浮動小数点演算の関係で、若干誤差が出てしまいます。それを調整します。<br />
　ポイントは、ここでも<b>TransformコンポーネントのPosition</b>を修正するのではなく、<b>RigidbodyコンポーネントのVelocity（速度）</b>を変更しているところです。<br />
<br />
<h4>障害物</h4>
　ここで配置される障害物は<b>FixedBoxクラス</b>です。コンストラクタで、<b>大きさ、回転、位置</b>を渡して構築する単純なクラスです。<br />
　<b>FixedBoxクラス</b>にも<b>衝突判定コンポーネントとRigidbodyコンポーネント</b>を追加します。<br />
　以下は、<b>void FixedBox::Create()関数</b>です。
<div class="box1">
<pre>
//初期化
void FixedBox::Create(){
    auto PtrTransform = GetComponent&lt;Transform>();

    PtrTransform->SetScale(m_Scale);
    PtrTransform->SetRotation(m_Rotation);
    PtrTransform->SetPosition(m_Position);

    <span class="red">auto PtrRegid = AddComponent&lt;Rigidbody>();
    auto PtrObb = AddComponent&lt;CollisionObb>();
    PtrObb->SetFixed(true);</span>

    //影をつける
    auto ShadowPtr = AddComponent&lt;Shadowmap>();
    ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");

    auto PtrDraw = AddComponent&lt;BasicPNTDraw>();
    PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
    PtrDraw->SetTextureResource(L"WALL_TX");
    PtrDraw->SetOwnShadowActive(true);
}
</pre>
</div>
　衝突判定コンポーネントの設定で
<div class="box1">
<pre>
    PtrObb->SetFixed(true);
</pre>
</div>
　と記述しています。この設定で、それ自身は反発して移動したりしません。<br />
<br />
<h4>ゲームステージ</h4>
　<b>GameStage.cpp</b>では、上記2つのクラスを配置しています。
<div class="box1">
<pre>
//ボックスの作成
void GameStage::CreateBox(){
    AddGameObject&lt;MoveObject>(Vector3(-8.0f, 0.5, 0), Vector3(7.0f, 0.0, 7.0f),true);
    AddGameObject&lt;MoveObject>(Vector3(0.0f, 0.5, 0), Vector3(-5.0f, 0.0, 6.0f),false);
    AddGameObject&lt;MoveObject>(Vector3(8.0f, 0.5, 0), Vector3(-7.0f, 0.0, 6.0f), true);
    AddGameObject&lt;MoveObject>(Vector3(0.0f, 0.5, 2.0f), Vector3(6.0f, 0.0, 5.0f), false);
}
//固定のボックスの作成
void GameStage::CreateFixedBox(){
    //配列の初期化
    vector&lt; vector&lt;Vector3> > Vec = {
        {
            Vector3(20.0f, 1.0f, 1.0f),
            Vector3(0.0f, 0.0f, 0.0f),
            Vector3(0.0f, 0.5f, 10.0f)
        },
        {
            Vector3(20.0f, 1.0f, 1.0f),
            Vector3(0.0f, 0.0f, 0.0f),
            Vector3(0.0f, 0.5f,-10.0f)
        },

        {
            Vector3(1.0f, 1.0f, 20.0f),
            Vector3(0, 0, 0),
            Vector3(10.0f, 0.5f, 0.0f)
        },
        {
            Vector3(1.0f, 1.0f, 20.0f),
            Vector3(0, 0, 0),
            Vector3(-10.0f, 0.5f, 0.0f)
        },
    };
    //オブジェクトの作成
    for (auto v : Vec){
        AddGameObject&lt;FixedBox>(v[0], v[1], v[2]);
    }
}
//初期化
void GameStage::Create(){
    try{
        //リソースの作成
        CreateResourses();
        //ビュー類を作成する
        CreateViews();
        //プレートを作成する
        CreatePlate();
        <span class="red">//固定ボックスの作成
        CreateFixedBox();
        //ボックスの作成
        CreateBox();</span>
    }
    catch (...){
        throw;
    }
}
</pre>
</div>
　<b>GameStage::Create()関数</b>で、構築する関数を呼ばないといけません。この記述は、結構忘れがちです。<br/>


</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_04.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_06.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
