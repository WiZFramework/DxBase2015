<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>１．更新補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>１０６．イベントとイベントマシン</h3>
<h4>スコアとイベント送信</h4>
　ゲームにおいて、ユーザーがどの程度頑張ったか、現在のプレイヤーと敵のライフの状態などなど、スコア類の表示は非常に重要です。<br />
　たとえば敵にやられたしまったときでも、<b>惜しかったのか、全然だめだったのか</b>により、ユーザーのモチベーションを左右します。<br/>
　そういったスコア全体を管理するクラスがあると便利です。<br />
　ここで紹介するスコアクラスは、プレイヤー及び敵から、<b>イベント</b>を受け取ります。<br />
　そしてそのイベントが敵からのものか、プレイヤーからのものかを振り分け、その時その時のスコアを表示します。<br />
　<b>Sample006ディレクトリ内</b>のソリューションを開いてリビルド、実行すると以下のような画面が現れます。
<p>&nbsp;</p>
<img src="img/1006a.jpg" width="80%"/>
<p>図1006a</p>
<p>&nbsp;</p>
　いきなり敵が砲弾を発射してくると思いますので、こちらも負けじと発射しましょう。コントローラのBボタンで発射します。<br />
<br />
　左上のスコアを注目してみましょう。プレーヤーのスコアと敵のスコアが表示されます。これらは、<b>スコアクラス</b>にメッセージを送ることで、スコアクラスがポイントを加算し、表示しています。<br />
<br />
<h4>イベントの送信</h4>
　イベントの送信はプレイヤー及び敵キャラから行います。<br />
　以下は、イベントを送信している部分です。
<div class="box1">
<pre>
    //砲弾と衝突した瞬間の処理
    void Player::ShellHitMotion(){
        //衝突判定を得る
        auto PtrCollision = GetComponent&lt;CollisionSphere>();
        //衝突した
        if (PtrCollision->GetHitObject()){
            auto ShellPtr = dynamic_pointer_cast&lt;ShellBall>(PtrCollision->GetHitObject());
            if (ShellPtr){
                //相手が砲弾だった
                //スコアオブジェクトにイベント送出
                auto PtrScoreObject = GetStage()->GetSharedGameObject&lt;ScoreObject>(L"ScoreObject");
                <span class="red">PostEvent(0, GetThis&lt;Player>(), PtrScoreObject, L"PlayerHit");</span>
            }

            //中略


        }
    }
</pre>
</div>
　抜粋してありますが、赤くなっているところでイベントを送っています。<b>PostEvent()関数</b>というのは、次のターン以降に相手がイベントを受け取ります。このほかに<b>SendEvent()関数</b>がありますが、はその時に相手に処理させます。こちらは相手側の処理が重くなり、また連続で送信したりすると、全体の動作に支障をきたすことがありますので、できるだけ<b>PostEvent()関数</b>を使用しましょう。<br />
<br />
　敵キャラも同様のモーション関数があり、そこからスコアオブジェクトに送信します。<br/>
<br />
<h4>スコアオブジェクト</h4>
　スコアクラスでは、上記のイベントを受け取りますが、この受け取り処理を<b>イベントステート</b>という、<b>ステート</b>と似たような処理で実装します。以下は、スコアクラスとイベントステートのヘッダです。<br />
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class ScoreObject : public GameObject;
    //  用途: スコアを表示するオブジェクト
    //--------------------------------------------------------------------------------------
    class ScoreObject : public GameObject{
        //イベントマシーン
        shared_ptr&lt; EventMachine&lt;ScoreObject> >  m_EventMachine;

        //中略

    public:

        //中略

        //イベントのハンドラ
        virtual void OnEvent(const shared_ptr&lt;Event>& event)override;
        //イベントが発生したときの演出関数
        //ポイントの加算
        void AddPointMotion(size_t sz);
        //敵ポイントの加算
        void AddEnemyPointMotion(size_t sz);
    };


    //--------------------------------------------------------------------------------------
    //  class TorusHitEvent : public EventState&lt;ScoreObject>;
    //  用途: トーラスが砲弾に当たったイベント
    //--------------------------------------------------------------------------------------
    class TorusHitEvent : public EventState&lt;ScoreObject>
    {
        TorusHitEvent(){}
    public:
        //イベントステートのインスタンスを得る
        static shared_ptr&lt;TorusHitEvent> Instance();
        //このイベントが発生したときに呼ばれる
        virtual void Enter(const shared_ptr&lt;ScoreObject>& Obj, const shared_ptr&lt;Event>& event)override;
    };

    //--------------------------------------------------------------------------------------
    //  class PlayerHitEvent : public EventState&lt;ScoreObject>;
    //  用途: プレイヤーが砲弾に当たったイベント
    //--------------------------------------------------------------------------------------
    class PlayerHitEvent : public EventState&lt;ScoreObject>
    {
        PlayerHitEvent(){}
    public:
        //イベントステートのインスタンスを得る
        static shared_ptr&lt;PlayerHitEvent> Instance();
        //このイベントが発生したときに呼ばれる
        virtual void Enter(const shared_ptr&lt;ScoreObject>& Obj, const shared_ptr&lt;Event>& event)override;
    };
</pre>
</div>
　抜粋してありますが、<b>ステート</b>と同じように、<b>モーション関数</b>を用意します。<br />
<br />
　実際のイベント振り分けは、Create()関数で指定します。

<div class="box1">
<pre>
    void ScoreObject::Create(){

        //中略

        //イベントマシンの構築
        m_EventMachine = make_shared&lt; EventMachine&lt;ScoreObject>>(GetThis&lt;ScoreObject>());
        //イベントキーとイベントステートを結び付ける
        m_EventMachine->AddEventState(L"TorusHit", TorusHitEvent::Instance());
        m_EventMachine->AddEventState(L"PlayerHit", PlayerHitEvent::Instance());

    }
</pre>
</div>
　こうしておくと、イベントハンドラ関数では以下のような記述になります。

<div class="box1">
<pre>
    //イベントのハンドラ
    void ScoreObject::OnEvent(const shared_ptr&lt;Event>& event){
        //ハンドラ関数呼び出し
        //これでイベントが振り分けられる
        m_EventMachine->HandleEvent(event);
    }
</pre>
</div>
　それぞれのイベントの受け取り関数は、以下のようになります。
<div class="box1">
<pre>
    //このイベントが発生したときに呼ばれる
    void TorusHitEvent::Enter(const shared_ptr&lt;ScoreObject>& Obj, const shared_ptr&lt;Event>& event){
        //ポイント加算
        Obj->AddPointMotion(1);
    }
</pre>
</div>
　上記は、<b>TorusHitEvent</b>の受け取り関数ですが、<b>PlayerHitEvent</b>も同様の記述になります。<br />
　それぞれ、<b>スコアのモーション関数</b>を呼び出します。<br />

<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="10_05.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
