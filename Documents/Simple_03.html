<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>シンプルDxBase2015</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>Simple03．３Ｄオブジェクトの描画</h3>
<br />
<h4>変換行列を使ったシェーダ</h4>
　今回は、ワールド行列を自分で設定し、カメラから、ビュー行列と射影行列を取得して３Ｄオブジェクトを描画する方法を説明します。前項までとは、シェーダも違います。<br />
　<b>DxBase2015Simple/Simple03</b>のソリューションを開いて、リビルド、実行しますと以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/Simple03a.jpg" width="80%"/>
<p>図Simple03a</p>
<p>&nbsp;</p>
　中央で８面体が回転してます。今回は、頂点の型を<b>VertexPositionNormalColor型</b>を使用します。<br />
<br />
<h4>シェーダの作成</h4>
　まずシェーダから作成します。以下は、シェーダの共通ヘッダである、<b>PRSimple3D.hlsli</b>です。
<div class="box1">
<pre>
cbuffer SimpleConstantBuffer : register(b0)
{
    float4x4 Model      : packoffset(c0);
    float4x4 View       : packoffset(c4);
    float4x4 Projection : packoffset(c8);
    float4 LightDir : packoffset(c12);
};


struct VertexShaderInput
{
    float4 Position : SV_Position;
    float3 Normal   : NORMAL;
    float4 Diffuse    : COLOR0;
};

struct PixelShaderInput
{
    float4 Position : SV_Position;
    float3 Normal   : NORMAL0;
    float4 Diffuse    : COLOR0;
};
</pre>
</div>
　頂点シェーダの入力とピクセルシェーダの入力は内容は同じですが、意味合いが違うので分けておきましょう。<br />
　コンスタントバッファも最低限の内容です。ここでは、<b>ワールド、ビュー、射影各行列と、ライトの向き（１個のライト）</b>を入力用に用意します。<br />
<br />
　以下は頂点シェーダです。
<div class="box1">
<pre>
#include "PRSimple3D.hlsli"

//--------------------------------------------------------------------------------------
// Vertex Shader
//--------------------------------------------------------------------------------------
PixelShaderInput main(VertexShaderInput input)
{
    PixelShaderInput vertexShaderOutput;
    float4 pos = input.Position;
    pos.w = 1.0;
    pos = mul(pos, Model);
    pos = mul(pos, View);
    pos = mul(pos, Projection);
    vertexShaderOutput.Position = pos;
    vertexShaderOutput.Normal = mul(float4(input.Normal, 1.0f), Model).xyz;
    vertexShaderOutput.Diffuse = input.Diffuse;
    return vertexShaderOutput;
}
</pre>
</div>
　ここでは、頂点の位置<b>input.Position</b>を、ワールド、ビュー、射影各行列を掛け算し、最終的なデバイス座標上の位置を割り出します。法線<b>input.Normal</b>は、入力時はローカル座標上の法線なので、それをワールド上の法線に変換します。頂点色<b>input.Diffuse</b>はそのままピクセルシェーダに渡します。<br />
<br />
　続いてピクセルシェーダです。
<div class="box1">
<pre>
#include "PRSimple3D.hlsli"

//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------
float4 main(PixelShaderInput input) : SV_TARGET
{
    //ライトの向きを得る
    float3 LightDirection = normalize(float3(LightDir.xyz));
    float3 InputNormal = normalize(input.Normal);
    //ライトによるピクセルの色を決定
    float4 LightColor = saturate(dot(InputNormal, LightDirection) + float4(0.7, 0.7, 0.7, 1.0));
    //ライトの透明処理はなし
    LightColor.a = 1;
    //デフィーズ色とライト色を合成
    return input.Diffuse * LightColor;
}
</pre>
</div>
　ここでは、ライトの向き（コンスタントバッファに渡されている）と法線から、ライティングによる色の変化を計算します。計算式の説明は<b><a href="40_02.html">４０２．頂点シェーダとピクセルシェーダの自作１</a></b>で説明してますので参照ください。<br />
　そこで計算したライト色と、ピクセルのデフィーズ色（ピクセルシェーダに渡った時点で、DirectXによってグラディーションが反映されている）を掛け合わせて最終カラーの出力にしています。<br/>
<br />
<h4>cpp側の作成</h4>
　これらのシェーダを管理する構造体、クラスは、<b>GameObjects.h</b>にあります、<b>Simple3DConstantBuffer、CBSimple3D、VSSimple3D、PSSimple3D</b>です。それぞれ使いまわしできるシングルトンとしてクラス化します。<br />
　このあたりの仕組みは<b>DxBase2015フルバージョン</b>と同じです。<br />
<br/>
　実際に、オブジェクトを実装するクラスは<b>GameObject</b>です。
<div class="box1">
<pre>
    class GameObject : public Object, public SimpleInterface{
        weak_ptr&lt;GameStage> m_GameStgae;
        Vector3 m_Scale;
        Quaternion m_Quaternion;
        Vector3 m_Position;
        Matrix4X4 m_WorldMatrix;
        //頂点バッファ
        ComPtr&lt;ID3D11Buffer> m_VertexBuffer;
        //インデックスバッファ
        ComPtr&lt;ID3D11Buffer> m_IndexBuffer;
        //頂点の数
        UINT m_NumVertices;
        //インデックスの数
        UINT m_NumIndicis;
        //メッシュの作成
        void CreateCustomMesh();
    public:
        //中略
    };
</pre>
</div>
　このように、メンバ変数が前項に比べ多くなっています。動的に動かすためには、このくらいの変数は必要です。<br />
　<b>weak_ptr&lt;GameStage> m_GameStgae;</b>はゲームステージの<b>weak_ptr</b>です。これを<b>shared_ptr</b>にすると、ゲームステージ側で<b>GameObjectのshared__ptr</b>を管理してますので、結果的に<b>shared__ptrをお互いに持つ</b>形になり、メモリリークを引き起こしますので注意しましょう。ゲームステージのポインタは、ビュー（を経由してカメラ）を取得するために持っておきます。<br />
　ほかのメンバは、<b>スケーリング、回転、位置とそれをまとめるワールド座標</b>です。<b>頂点バッファと、今回はインデックスバッファも</b>使用します。<br/>
<br/>
　これらの初期設定は、スケール、回転、位置は<b>コンストラクタ</b>で、頂点の作成は<b>GameObject::Create()</b>で行います。以下はCreate()関数です。
<div class="box1">
<pre>
    void GameObject::Create(){
        //頂点を作成するための配列
        vector&lt;VertexPositionNormalTexture> vertices;
        vector&lt;uint16_t> indices;
        <span class="red">//正8面体の作成
        VertexUtil::CreateOctahedron(1.0f, vertices, indices);</span>
        //頂点を変更するための配列
        vector&lt;VertexPositionNormalColor> set_vertices;
        for (auto V : vertices){
            Color4 Col;
            if (V.position.y > 0){
                Col = Color4(1.0f, 1.0f, 0.0f, 0.0f);
            }
            else if (V.position.y &lt; 0){
                Col = Color4(0.0f, 1.0f, 1.0f, 0.0f);
            }
            else{
                if (V.position.x == 0.0f){
                    Col = Color4(1.0f, 1.0f, 0.0f, 1.0f);
                }
                else if (V.position.x > 0.0f){
                    Col = Color4(0.0f, 0.0f, 1.0f, 1.0f);
                }
                else{
                    Col = Color4(1.0f, 0.0f, 0.0f, 1.0f);
                }

            }
            set_vertices.push_back(
                VertexPositionNormalColor(V.position, V.normal, Col)
                );
        }
        //頂点バッファの作成（頂点は変更できない）
        VertexUtil::CreateVertexBuffer(m_VertexBuffer, set_vertices);
        //頂点数の設定
        m_NumVertices = static_cast&lt;UINT>(set_vertices.size());
        //インデックスバッファの作成
        VertexUtil::CreateIndexBuffer(m_IndexBuffer, indices);
        //インデックス数の設定
        m_NumIndicis = static_cast&lt;UINT>(indices.size());

        m_WorldMatrix.DefTransformation(m_Scale, m_Quaternion, m_Position);
    }
</pre>
</div>
　赤くなっている<b>VertexUtil::CreateOctahedron()</b>で、正8面体を作成しています。<br />
　このほかにも、<b>VertexUtil::CreateCube()</b>など、プリミティブ形状を作成するユーティリティがありますので各自調べてください。ライブラリ中<b>VertexHelper.h、cpp</b>にあります。<br />
　これらのユーティリティ関数は<b>VertexPositionNormalTexture型</b>の頂点とインデックスを作成します。頂点の型を変更したい時は、上記のように、別の型の配列に必要な部分のみ取り出し、再設定します。<br />
　上記の例ですと<b>VertexPositionNormalColor型</b>に変更します。当然<b>Color要素</b>は実装されてませんので、各自設定します。ここでは、グラディーションができるように、頂点によって色を変化させています。<br/>
　頂点の配列の設定が終わったら、<b>VertexUtil::CreateVertexBuffer()テンプレート関数</b>で頂点バッファを作成します。今回は頂点変更ができないバッファです。変更できるようにしたい場合は、前項を参照ください。この関数はテンプレートになってますので、いろんな頂点型を受け付けます。<br />
　最後に<b>m_WorldMatrix.DefTransformation()関数</b>で、ワールド行列を作成しています。<br />
<br />
　<b>Update()仮想関数</b>で、回転を追加します。回転の方はクオータニオンなので、1回分の回転を導き（ターン時間で設定します）、それを現在の回転に追加し、最終的にワールド行列を作成します。
<div class="box1">
<pre>
    void GameObject::Update(){
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        Quaternion SpanQt;
        SpanQt.RotationRollPitchYawFromVector(Vector3(0, ElapsedTime, 0));
        m_Quaternion *= SpanQt;
        m_WorldMatrix.DefTransformation(m_Scale, m_Quaternion, m_Position);
    }
</pre>
</div>
　最後に<b>Draw()</b>です。
<div class="box1">
<pre>
    void GameObject::Draw(){
        //ゲームステージが無効ならリターン
        if (m_GameStgae.expired()){
            return;
        }
        //デバイスの取得
        auto Dev = App::GetApp()->GetDeviceResources();
        auto pDx11Device = Dev->GetD3DDevice();
        auto pID3D11DeviceContext = Dev->GetD3DDeviceContext();
        //ステータスのポインタ
        auto RenderStatePtr = Dev->GetRenderState();
        auto Stage = m_GameStgae.lock();
        <span class="red">auto ViewPtr = Stage->GetView();</span>
        //ビューからカメラを取り出す
        auto PtrCamera = ViewPtr->GetCamera();
        //カメラの取得
        Matrix4X4 View, Proj;
        View = PtrCamera->GetViewMatrix();
        Proj = PtrCamera->GetProjMatrix();

        //コンスタントバッファの設定
        Simple3DConstantBuffer cb1;
        //行列の設定(転置する)
        cb1.Model = Matrix4X4EX::Transpose(m_WorldMatrix);
        cb1.View = Matrix4X4EX::Transpose(View);
        cb1.Projection = Matrix4X4EX::Transpose(Proj);
        //ライトの設定
        //ステージから0番目のライトを取り出す
        auto PtrLight = ViewPtr->GetMultiLight()->GetLight(0);
        cb1.LightDir = PtrLight->GetDirectional();
        cb1.LightDir.w = 1.0f;

        //コンスタントバッファの更新
        pID3D11DeviceContext->UpdateSubresource(
            CBSimple3D::GetPtr()->GetBuffer(), 0, nullptr, &cb1, 0, 0);
        //ストライドとオフセット
        UINT stride = sizeof(VertexPositionNormalColor);
        UINT offset = 0;
        //頂点バッファの設定
        pID3D11DeviceContext->IASetVertexBuffers(
            0, 1, m_VertexBuffer.GetAddressOf(), &stride, &offset);
        //インデックスバッファのセット
        pID3D11DeviceContext->IASetIndexBuffer(m_IndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0);
        //描画方法（3角形）
        pID3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
        //半透明処理
        pID3D11DeviceContext->OMSetBlendState(
            RenderStatePtr->GetAlphaBlendEx(), nullptr, 0xffffffff);
        //デプスステンシルは使用する
        pID3D11DeviceContext->OMSetDepthStencilState(RenderStatePtr->GetDepthDefault(), 0);
        //シェーダの設定
        pID3D11DeviceContext->VSSetShader(VSSimple3D::GetPtr()->GetShader(), nullptr, 0);
        pID3D11DeviceContext->PSSetShader(PSSimple3D::GetPtr()->GetShader(), nullptr, 0);
        //インプットレイアウトの設定
        pID3D11DeviceContext->IASetInputLayout(VSSimple3D::GetPtr()->GetInputLayout());
        //コンスタントバッファの設定
        ID3D11Buffer* pConstantBuffer = CBSimple3D::GetPtr()->GetBuffer();
        pID3D11DeviceContext->VSSetConstantBuffers(0, 1, &pConstantBuffer);
        pID3D11DeviceContext->PSSetConstantBuffers(0, 1, &pConstantBuffer);
        //レンダリングステート
        pID3D11DeviceContext->RSSetState(RenderStatePtr->GetCullFront());
        //描画
        pID3D11DeviceContext->DrawIndexed(m_NumIndicis, 0, 0);
        //レンダリングステート
        pID3D11DeviceContext->RSSetState(RenderStatePtr->GetCullBack());
        //描画
        pID3D11DeviceContext->DrawIndexed(m_NumIndicis, 0, 0);
        //後始末
        Dev->InitializeStates(RenderStatePtr);
    }
</pre>
</div>
　前項を少し複雑にし、あるいは４章で説明した内容とほぼ同じですが、カメラや、ライトの取得方法が違います。ゲームステージにビュークラスがありますので、<b>auto ViewPtr = Stage->GetView()</b>のようにゲームステージからビューを取得し、そのポインタを介してカメラやライトを取り出します。<br />
　また、今までも出てきましたが透明処理するので、２回描画しています。<br />
<br />
<h4>ゲームステージ</h4>
　今回は、ゲームステージも修正します。ビューを取り出せるようにアクセサを作成するのと、今回はカメラやライトも重要ですので、ビューのUpdate()を呼び出します。これを呼ばないとカメラのビュー行列や射影行列が設定されません。
<div class="box1">
<pre>
    void GameStage::Update(){
        <span class="red">//ビューの変化
        m_View->Update();</span>
        //オブジェクトの変化
        for (auto Obj : m_GameObjectVec){
            Obj->Update();
        }
        auto fps = App::GetApp()->GetStepTimer().GetFramesPerSecond();
        wstring FPS(L"FPS: ");
        FPS += Util::UintToWStr(fps);
        //文字列の変化
        m_StringSprite->SetText(FPS);
        m_StringSprite->Update();
    }
</pre>
</div>
　このように、<b>DxBase2015フルバージョン</b>に比べると記述するコード量が違いますが、一つ一つ理解しながら記述するようにすれば、次第に慣れてくると思います。

<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="Simple_02.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
