<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>４．独自の頂点と独自描画</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>４０８．ジオメトリシェーダの利用</h3>
<br />
<h4>ジオメトリシェーダとは</h4>
　<b>DxBase2015</b>には、<b>頂点シェーダ、ピクセルシェーダ</b>のほかに<b>ジオメトリシェーダと計算シェーダ</b>用のクラスが用意されています。<br />
　このほかに<b>DirectX11が持ってるシェーダ</b>には<b>ハルシェーダとドメインシェーダ</b>がありますが、こちら用にはクラスが用意されてません。ですので<b>ハルシェーダとドメインシェーダ</b>の実装は不可能ではありませんが、0からシェーダへのアクセスクラスを作る必要があります。これらについての対応は<b>次期バージョン（DirectX12用DxBase）</b>をお待ちください。<br />
　<b>ジオメトリシェーダと計算シェーダ</b>は、クラスが用意されていますが、<b>Draw()に直結する</b>のは<b>ジオメトリシェーダ</b>です。<b>計算シェーダ</b>は、計算処理をCPUで行うのではなく、GPUに計算させる手法で、扱いが別になります。<br />
<br />
　というわけで、この項では<b>ジオメトリシェーダ</b>のサンプルの紹介をするわけですが、では<b>ジオメトリシェーダ</b>とは何か、と簡単に説明します。<br />
　これまでのサンプルで、頂点処理は<b>頂点シェーダ</b>ピクセル処理は<b>ピクセルシェーダ</b>が行い、それぞれどのような内容を記述すべきかが見えてきたと思います。このセットは単位を<b>頂点、もしくはピクセル</b>で扱うことで、細かな制御が可能になります。<br />
　しかし、時には、<b>描画プリミティブ単位</b>で考えたいことがあります。<b>描画プリミティブ単位</b>とは<b>三角形</b>とか<b>線</b>とか<b>点</b>です。<br />
　<b>DirectX11</b>は、描画するときに、渡した頂点バッファを、<b>どのようなプリミティブ単位で描画すべきか</b>を指定します。一般的な３Ｄや２Ｄであれば、<b>三角形単位</b>、であり、前項では<b>線単位</b>、とか<b>点単位</b>を説明しました。<br />
　ところが<b>頂点シェーダが扱うのは点単位のみ</b>です。すると、シェーダを記述する際、いまどの頂点に対する計算を行おうとしているのか、あるいは、現在の頂点は、三角形のどの位置にあるものなのかわかりません。（インデックスは持ってこれるのですが、ここでほしいのは、三角形の中のどの頂点かということです）<br />
　<b>ジオメトリシェーダ</b>はこの不満に答えてくれます。そして、これこそ<b>ジオメトリシェーダの機能</b>なのですが、シェーダ内で<b>頂点を増やすことができる</b>のです。<br />
　このことにより、たとえば、レーシングゲームなどで、同じシーンを複数のカメラで表示することもあると思います（これは画面分割のサンプルで説明しました）<br />
　このとき、メインのプレイヤーのワールド行列等情報と、他のビューのカメラ情報があれば、同時に複数のビューに記述することが可能です。<br />
　また、１つの三角形を細かい三角形に分割することにより、１つのオブジェクトをバラバラにすることも可能です。<br />
　そのほか、アイディア次第では、表現方法が大幅に増えます。<br />
　なお<b>ジオメトリシェーダ</b>は、<b>頂点シェーダとピクセルシェーダの間</b>に実装されます。<br />
<br/>
<h4>ジオメトリシェーダの実装</h4>
　では<b>Sample408ディレクトリ</b>のソリューションを開き、リビルド、実行してみましょう。以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/4008a.jpg" width="60%"/>
<p>図4008a</p>
<p>&nbsp;</p>
　この画面は、実は、<b>Sample406</b>で実装したのと同じものが描画されています。<br />
　違うのは、<b>描画方法</b>です。<b>Sample406</b>では、３つのゲームオブジェクトを作成して表示していましたが、この項では<b>ジオメトリックシェーダ</b>を使って、３つ描画しているのです。<br />
　まず、方針的には、<b>Sample406</b>のときは、オブジェクトのワールド行列をオブジェクトごとにシェーダーに渡していましたが、今回は1回（センターのオブジェクトの描画）時に、<b>3つのワールド行列</b>を渡します。そして、そのワールド行列の数だけ（つまり3つに）三角形を増やします。<br />
　まず、cpp側の準備として、コンスタントバッファ構造体を修正します。<b>Character.h</b>に記述します。
<div class="box1">
<pre>
    //カスタム描画コンスタントバッファ構造体
    struct CustomDrawConstantBuffer
    {
        <span class="red">Matrix4X4 World[3];</span>
        Matrix4X4 View;
        Matrix4X4 Projection;
        Vector4 LightDir;
        Vector4 Param;  //汎用パラメータ
        CustomDrawConstantBuffer() {
            memset(this, 0, sizeof(CustomDrawConstantBuffer));
        };
    };
</pre>
</div>
　赤くなっているところを見ればわかるように、ワールド行列が配列になっています。<br />
　続いて、シェーダを記述します。シェーダーのインクルードファイルも、コンスタントバッファに合わせてワールド行列を3つにします。<b>SimpleInc.hlsli</b>です。
<div class="box1">
<pre>
cbuffer SimpleConstantBuffer : register(b0)
{
    <span class="red">float4x4 World[3] : packoffset(c0);</span>
    float4x4 View   : packoffset(c12);
    float4x4 Projection : packoffset(c16);
    float4 LightDir : packoffset(c20);
    float4 Param : packoffset(c21);
};
</pre>
</div>
　各<b>packoffsetの値</b>も変わるので注意しましょう。<br />
　このほかに、ジオメトリシェーダの入力をtypedefで宣言しておきます。
<div class="box1">
<pre>
typedef VertexShaderInput GeometryShaderInput;
</pre>
</div>
　続いて頂点シェーダです。
<div class="box1">
<pre>
#include "SimpleInc.hlsli"

GeometryShaderInput main(VertexShaderInput input)
{
    //ジオメトリシェーダーに渡す変数
    //入力をそのまま出力する
    GeometryShaderInput vertexShaderOutput
        = (GeometryShaderInput)input;
    return vertexShaderOutput;
}
</pre>
</div>
　このように、処理を<b>ジオメトリシェーダに任せます</b>ので入力をスルーしてリターンします。<br />
　以下が<b>ジオメトリシェーダ</b>です。
<div class="box1">
<pre>
#include "SimpleInc.hlsli"

<span class="red">[maxvertexcount(9)]
void main(
    triangle GeometryShaderInput input[3],
    inout TriangleStream&lt; PixelShaderInput > output
)</span>
{
    for (uint count = 0; count &lt; 3; count++){
        for (uint i = 0; i &lt; 3; i++)
        {
            PixelShaderInput element;
            //頂点の位置を変換
            float4 pos = float4(input[i].pos.xyz, 1.0f);
            float4 Col;
            if (pos.y > 0){
                switch (count){
                case 0:
                    Col = float4(1.0f, 0.0f, 0.0f, 0.0f);
                    break;
                case 1:
                    Col = float4(0.0f, 1.0f, 0.0f, 0.0f);
                    break;
                case 2:
                    Col = float4(0.0f, 0.0f, 1.0f, 0.0f);
                    break;
                default:
                    Col = float4(1.0f, 1.0f, 1.0f, 1.0f);
                    break;
                }
            }
            else if (pos.y &lt; 0){
                switch (count){
                case 0:
                    Col = float4(0.0f, 1.0f, 0.0f, 0.0f);
                    break;
                case 1:
                    Col = float4(0.0f, 0.0f, 1.0f, 0.0f);
                    break;
                case 2:
                    Col = float4(1.0f, 0.0f, 0.0f, 0.0f);
                    break;
                default:
                    Col = float4(1.0f, 1.0f, 1.0f, 1.0f);
                    break;
                }
            }
            else{
                Col = float4(1.0f, 1.0f, 1.0f, 1.0f);
            }
            //ワールド変換
            pos = mul(pos, World[count]);
            //ビュー変換
            pos = mul(pos, View);
            //射影変換
            pos = mul(pos, Projection);
            //ピクセルシェーダに渡す変数に設定
            element.pos = pos;
            //ライティング用に法線をワールド変換して設定
            element.norm = mul(input[i].norm, (float3x3)World[count]);
            //頂点色を設定
            element.color = Col;
            //頂点を追加
            <span class="red">output.Append(element);</span>
        }
        //一つの三角形をストリームに送る
        <span class="red">output.RestartStrip();</span>
    }
}
</pre>
</div>
　コードの全般は、左右のオブジェクトの色を変更する処理です。注意点は赤くなっているところです。
<div class="box1">
<pre>
<span class="red">[maxvertexcount(9)]
void main(
    triangle GeometryShaderInput input[3],
    inout TriangleStream&lt; PixelShaderInput > output
)</span>
</pre>
</div>
　は<b>main()</b>に渡す変数の宣言ですが、<b>[maxvertexcount(9)]</b>というのは作成する頂点の最大数です。ここでは、<b>3つの頂点（つまり三角形）から3つの三角形</b>を作りますので<b>9</b>になります。<br />
　<b>triangle GeometryShaderInput input[3]</b>というのは、まさに入力される三角形の頂点データです。<br />
　<b>inout TriangleStream&lt; PixelShaderInput > output</b>はピクセルシェーダに渡す変数です。構造体の型を記述しておきます。<br />
　内容的には、1つの三角形を元に3つの三角形を作成して、ピクセルシェーダに渡すわけですが、1つの頂点ができた段階で、
<div class="box1">
<pre>
            //頂点を追加
            <span class="red">output.Append(element);</span>
</pre>
</div>
　のように頂点を出力に送ります。<br />
　また、1つの三角形分の頂点を送った段階で、
<div class="box1">
<pre>
        //一つの三角形をストリームに送る
        <span class="red">output.RestartStrip();</span>
</pre>
</div>
　のように、いったん締めます。そうして3個の三角形をoutputに送ります。<br />
<br/>
　これでシェーダの記述は終わりです。ピクセルシェーダは<b>Sample406</b>と変更ありません。<br />
<br />
<h4>cpp側の実装</h4>
　cpp側の実装は、先にコンスタントバッファ構造体の変更は説明しましたが、そのほかに、<b>ジオメトリシェーダ用のクラス</b>を作成します。<b>ピクセルシェーダの作成</b>とほぼ同じです。<b>GSCustomDraw</b>というクラスです。<br />
<br />
　あとは、コンストラクタのパラメータで色パターンを渡してましたが、これはシェーダ内で行うので削除して、<b>Draw()</b>を記述します。<br />
　<b>Draw()</b>も大きな変更はありませんが、<b>ジオメトリシェーダをset</b>するところと、<b>ワールド行列を3つコンスタントバッファに渡す</b>ところが注意点です。
<div class="box1">
<pre>
    void CustomDrawOctahedron::Draw(){
        //中略

        //コンスタントバッファの設定
        CustomDrawConstantBuffer cb1;
        //行列の設定(転置する)
        <span class="red">cb1.World[0] = Matrix4X4EX::Transpose(PtrT->GetWorldMatrix());
        Matrix4X4 Left = Matrix4X4EX::Translation(-5.0f, 0, 0);
        Left = PtrT->GetWorldMatrix() * Left;
        cb1.World[1] = Matrix4X4EX::Transpose(Left);
        Matrix4X4 Right = Matrix4X4EX::Translation(5.0f, 0, 0);
        Right = PtrT->GetWorldMatrix() * Right;
        cb1.World[2] = Matrix4X4EX::Transpose(Right);</span>

        //中略

        //シェーダの設定
        pID3D11DeviceContext->VSSetShader(VSCustomDraw::GetPtr()->GetShader(), nullptr, 0);
        <span class="red">pID3D11DeviceContext->GSSetShader(GSCustomDraw::GetPtr()->GetShader(), nullptr, 0);</span>
        pID3D11DeviceContext->PSSetShader(PSCustomDraw::GetPtr()->GetShader(), nullptr, 0);
        //インプットレイアウトの設定
        pID3D11DeviceContext->IASetInputLayout(VSCustomDraw::GetPtr()->GetInputLayout());
        //コンスタントバッファの設定
        ID3D11Buffer* pConstantBuffer = CBCustomDraw::GetPtr()->GetBuffer();
        pID3D11DeviceContext->VSSetConstantBuffers(0, 1, &pConstantBuffer);
        <span class="red">pID3D11DeviceContext->GSSetConstantBuffers(0, 1, &pConstantBuffer);</span>
        pID3D11DeviceContext->PSSetConstantBuffers(0, 1, &pConstantBuffer);

        //中略

    }
</pre>
</div>
　このような感じです。<br />
<br />
　これで、オブジェクトは3つ描画するようになりますが、影は一つだけです。そのため、<b>CustomShadowmap</b>側でも同様のジオメトリシェーダを追加します。<br />
<br />
　最後に、GameStage.cppで追加するオブジェクトは、中央ののみ一つだけ追加します。<br />
<br />
<h4>最後に</h4>
　<b>ジオメトリシェーダを使う</b>と、描画速度は目に見えて速くなります。今回のような3つくらいではあまり感じませんが、これが50個100個と増えていくと、その違いが判ります。<br />
　しかし<b>ジオメトリシェーダ</b>にも欠点があります。まず、増やす（ストリームに送る）最大頂点数をあらかじめ決めなければならないところです。しかし、これは、<b>1回の描画での追加数をあまり増やさずに、何回かに分けで描画する</b>ことである程度自由度が上がります。<br/>
　もう1つが、これは<b>DxBase2015との関係</b>ですが、<b>衝突判定</b>などは増やすオブジェクトにはつけられないということです。同じオブジェクトを複数のカメラで見る場合は、問題ありませんが今回のようにオブジェクトそのものが増える形であれば実装は難しいです。<br />
　しかし、<b>Sample404</b>で述べたように、OBBはそのままオブジェクトが保持し、描画だけマネージャに任せる、という手法をとれば、<b>マネージャの処理の部分</b>だけ、<b>ジオメトリシェーダ</b>を使う方法があります。これでもかなり描画速度は上がります。<br />
<br />
　こうしてみると、<b>ジオメトリシェーダ</b>はアイディア次第という側面が大きいのがわかります。皆さんも、なにかを大量に描画する、あるいは、三角形を細かく分割する必要があったときに<b>ジオメトリシェーダ</b>の利用を検討してみてください。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="40_07.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
