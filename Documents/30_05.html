<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３０５．描画レイヤーの変更</h3>
<br />
<h4>透明オブジェクトの扱い</h4>
　透明オブジェクトは、<b>GameObjectのメンバ関数</b>で<b>SetAlphaActive(true);</b>とすればそのオブジェクトは透明処理をします。<br/>
　では<b>透明処理</b>とは、具体的にどうしてるかというと、<b>ブレンドステート</b>と呼ばれる掛け合わせ処理を実装するわけですが、問題は、<b>どういう順番で描画するか</b>が重要です。<br />
　デフォルトの処理としては、まず、毎ターンごとに、<b>透明ではないオブジェクト</b>をすべて描画した後、<b>透明なオブジェクト</b>を描画します。<b>透明なオブジェクト同士の描画順</b>は、<b>カメラから遠いところにあるオブジェクト</b>から順番に描画します。<br />
　では、そのオブジェクトの位置はどこから取得してるかというと、単純にワールド上のポジション、つまり<b>TransformコンポーネントのPosition</b>から取得します。<br />
　これでだいたい透明処理はうまくいくのですが、何点かケースによってはうまくいかない場合があります。<br />
　<b>Sample305</b>はうまくいかないケースのときの対処方法のサンプルです。<br />
　<b>Sample305</b>ディレクトリのソリューションを開いて、リビルド、そして実行すると以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/3005a.jpg" width="80%"/>
<p>図3005a</p>
<p>&nbsp;</p>
　中央に、ボックスと半球のオブジェクトがあります。プレイヤーをその中に潜り込ませると、図のようにプレイヤーが消えてしまいます。<br/>
　これは、<b>透明オブジェクト同士の描画順</b>に問題があるために起こります。<br />
　透明オブジェクトが重なってる場合、<b>基本的に内側から</b>描画します。このサンプルの場合、<b>プレイヤー、内側の半球、外側のボックス</b>の順番です。<br />
　直感的には、<b>では、オブジェクトの追加の順番を上記のようにすればいいのでは</b>と思うかも知れません。基本的にはそうです。<b>透明オブジェクト同士の描画順</b>は<b>追加された順番</b>にカメラとの距離を計算しますので、結果的に今回のケースではうまくいきます。<br />
　しかし、オブジェクトを動的に追加するような場合はこうはいきません。動的に追加した場合は、最後に追加されますので制御できません。<br />
<br />
<h4>描画レイヤー</h4>
　こんなときに設定するのが<b>描画レイヤー</b>です。各オブジェクトは、描画を、<b>レイヤーごと</b>に行います。レイヤーとは、実体は単純な<b>int型の値</b>です。デフォルトは0です。<br />
　通常のものより、早く描画したければ、値を小さくします。後に描画したければ値を大きくします。<br/>
　以下は、透明ボックスの<b>Create()関数</b>です。レイヤーを設定しています。
<div class="box1">
<pre>
    void TraceBox::Create(){

        //中略
        
        //透明処理
        SetAlphaActive(true);
        <span class="red">//レイヤーを指定する場合は、以下コメントを外す
        SetDrawLayer(2);</span>
    }
</pre>
</div>
　コメントになっていますので、コメントを外すだけで大丈夫です。ここでは<b>レイヤーを2</b>にしています。<br />
　また、以下は半球の<b>Create()関数</b>です。
<div class="box1">
<pre>
    void TraceSphere::Create(){

        //中略

        //透明処理
        SetAlphaActive(true);
        <span class="red">//レイヤーを指定する場合は、以下コメントを外す
        SetDrawLayer(1);</span>
    }
</pre>
</div>
　こちらは、<b>レイヤーは1</b>にしています。<br/>
<br />
　このような設定で、あとプレイヤーはデフォルトのままですので、<b>レイヤーは0</b>です。<br/>
　そうすると、<b>プレイヤー、半球、ボックス</b>の順番に描画されることになります。<br />
　その実行結果が以下です。プレイヤーが潜りこんでも消えませんし、ボックスの隙間から、半球が覗けます。<p>&nbsp;</p>
<img src="img/3005b.jpg" width="80%"/>
<p>図3005b</p>
<p>&nbsp;</p>
　ただ一つ問題があります。本来なら、ボックスの模様（赤い帯）は、半球内に突き抜けて見えなくてはいけません。しかし、半球をボックスより先に描画しているために、その部分は描画されません。<br />
　これを回避するには、ボックスの上部のみ、たとえばスクエアで作成し、そのオブジェクトを、<b>プレイヤーの後で半球の前</b>に描画すれば、出るようになります。<br />
　あるいは、シェーダで、オブジェクト内の描画する三角形を分けるか、なども考えられます。<br />
　しかし、そのためには新たな<b>GameObject</b>を作成せねばならず。その模様（テクスチャ）も、ボックスと重なって違和感ないように調整しなければなりません。シェーダを作成するとなればもっと大変です。<br />
　こんな場合は、プリミティブで作成するのをやめて、のちのサンプルで説明する<b>FBXモデル</b>を作成するか、あるいは、このような透明の重なりをなくす（一部透明でないオブジェクトもまぜ、テクスチャなどで違和感ないようにする）などの方法が望ましいでしょう。<br />
　ようは、そのオブジェクトの重要度と実装する手間、とのかねあいかと思います。


<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="30_04.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="30_06.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
