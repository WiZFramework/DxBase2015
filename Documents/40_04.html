<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>４．独自の頂点と独自描画</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>４０４．プリミティブ頂点の変更と最適化</h3>
　この項では、<b>最適化</b>について考えます。ステージ上に配置されるオブジェクトがどんどん増えていった場合、どうしても描画速度に影響してきます。<br />
　配置される大量のオブジェクトが、全く別のクラス（タイプ）のオブジェクトであれば仕方がないですが、そういうことはめったになく、たいがいは同じタイプのオブジェクトが大量に配置する必要に迫られます。<br />
<br />
<h4>最適化が必要なわけ</h4>
　たとえばステージを作成する場合、ステージ上に<b>マップ</b>といわれるいくつかのブロックにわけたデータを用意する場合があります。以下のようなイメージです。
<p>&nbsp;</p>
<img src="img/4004a.jpg" width="60%"/>
<p>図4004a</p>
<p>&nbsp;</p>
　これを、以下のように<b>0、1</b>といった数字で表現します。以下のようになります。
<p>&nbsp;</p>
<img src="img/4004b.jpg" width="60%"/>
<p>図4004b</p>
<p>&nbsp;</p>
　これを３Ｄで表現するとして、マップを上から見たデータとすると、真っ先に思いつくのが、<b>1に対応する場所に立方体を配置する</b>というものです。<br />
　たしかに、<b>大は小を兼ねる</b>ではないですが、小さな立方体を<b>たてよこ（あるいは高さ）</b>に伸ばせば直方体ができますので、この方法も一理あります。しかし、そのようにして作成した立方体の数を数えてみましょう。2次元のマップでたとえば、<b>30×30のサイズがあった場合、最高で900</b>の立方体が必要です。<br />
　もちろん、<b>0の部分もあるので、半分が立方体としても450</b>必要です。これで、<b>高さが、たとえば10</b>あったらどうでしょう？<b>1000個以上</b>にすぐになってしまいます。<br/>
　この負荷はすぐにゲームに影響します。システムのスピードにもよりますが、標準的なWindows8.1マシンで、300個を超えたあたりから、動きが怪しくなります。<br />
<br />
<h4>形状の最適化</h4>
　まず考え付く最適化は立方体をいくつかまとめて直方体にする方法です。以下のように最適化します。
<p>&nbsp;</p>
<img src="img/4004c.jpg" width="60%"/>
<p>図4004c</p>
<p>&nbsp;</p>
　こうすることで、<b>今まで20個あった立方体が、8個の直方体に</b>減らすことができます。手法としては。<b>まず横方向に2マス以上あった場合は横方向に限界まで伸ばし、続いて残ったマスを縦方向に伸ばす</b>という手法でこのように最適化できます。<br />
　このようにして<b>小さなオブジェクトをまとめて大きなオブジェクトにする</b>という最適化は、かなり有効です。<br />
<br />
<h4>描画の最適化</h4>
　上記の最適化で形状はある程度まとめられますが、それでも、<b>DxBase2015フレームワーク</b>の場合、各直方体は1個1個が別々のオブジェクトなので、描画は直方体の数だけ行われます。<b>DirectX11への設定と設定を元に戻す処理</b>が直方体の数だけ行われるので、それはそれで無駄な処理が入ります。<br />
　そのため、描画の最適化の方法として、直方体1つ1つを描画するのをやめて、全体で1個のオブジェクトとして描画します。しかし、描画以外の処理（Update処理）は、直方体の状態で行います。<br />
　この処理をすることで、衝突判定等はOBBの状態で行い、描画のみ全体で1回という最適化を行うことができます。<br />
<br />
<h4>サンプル説明</h4>
　<b>Sample404のソリューション</b>を開いてリビルド、実行すると以下の画面が現れます。<br />
<p>&nbsp;</p>
<img src="img/4004d.jpg" width="80%"/>
<p>図4004d</p>
<p>&nbsp;</p>
　このように全体的に<b>迷路</b>が配置されています。<br />
　この迷路は、動的に作成されたもので、有名な迷路アルゴリズムを利用しています。<br />
　<b>GameStage.h、cpp</b>の<b>Labyrinthクラス</b>が<b>迷路クラス</b>です。コンストラクタに、<b>幅と奥行きのマップ数（6以上の偶数）</b>を渡すと、その数のマップの迷路を作成します。これで作成された迷路は、<b>壁の部分が1、そうでない部分が0</b>になります。上記で説明したマップのフォーマットと同じです。サンプルでは30×30のマップを作成しています。<br />
<br />
　この動的に作成した迷路マップを読み込んで、<b>FixedBoxクラス</b>を作成します。このクラスは<b>チュートリアル008などのFixedBoxクラス</b>とほぼ同じです。<b>Charactor.h。cpp</b>に記述があります。<br />
　違う部分は、<b>Create()関数で、SetDrawActive(false)</b>と設定している部分です。これにより、<b>FixedBoxクラス</b>がそれぞれ描画することはなくなります。<br />
<br/>
<h4>迷路の読み込みと、FixedBoxの作成</h4>
　迷路の読み込みとFixedBoxの作成は<b>GameStage.cppのGameStage::CreateFixedBox()関数</b>に記述があります。
<div class="box1">
<pre>
    void GameStage::CreateFixedBox(){
        //マネージャから参照できるようにグループを作成
        CreateSharedObjectGroup(L"FIXED_BOX");
        //迷路の作成
        <span class="red">Labyrinth labyrinth(m_MapSizeX, m_MapSizeZ);
        //迷路マップの取得
        auto& LabMap = labyrinth.GetMap();</span>
        //横軸
        vector&lt; vector&lt;int> > DataMap;
        ChangeVecXZ(LabMap, DataMap);
        //一番外の壁に接している通路を作成
        for (size_t i = 1; i &lt; DataMap.size() - 1; i++){
            auto line = DataMap[i];
            for (size_t j = 1; j &lt; line.size() - 1; j++){
                if (i == 1 || i == (DataMap.size() - 2)){
                    DataMap[i][j] = 0;
                }
                if (j == 1 || j == (line.size() - 2)){
                    DataMap[i][j] = 0;
                }

            }
        }
        //横軸のセット
        <span class="red">SetFixedBox(DataMap, true);</span>
        //縦軸
        vector&lt; vector&lt;int> > DataMap2;
        ChangeVecXZ(DataMap, DataMap2);
        //縦軸のセット
        <span class="red">SetFixedBox(DataMap2, false);</span>
        //ボックス描画マネージャの作成
        <span class="red">AddGameObject&lt;FixedBoxManager>();</span>
    }
</pre>
</div>
　赤くなっているところは、迷路マップを取り出すところと、横軸、縦軸のFixedBoxを作成しているところです。詳細は各関数を参照ください。<br/>
　最後の行の、
<div class="box1">
<pre>
        //ボックス描画マネージャの作成
        <span class="red">AddGameObject&lt;FixedBoxManager>();</span>
</pre>
</div>
　は、<b>すべてのFixedBoxをまとめて1つのオブジェクトとして描画するクラス</b>です。<br />
　これも<b>Charactor.h、cpp</b>に記述があります。<br />
　その<b>FixedBoxManager::Create()関数</b>で、<b>各FixedBoxのワールド行列</b>から、頂点を作成しています。つまり、ワールド行列の値と同じ頂点の集合になります。またここで、テクスチャのUV値もタイリングするようにします。<br />
　それで、一度に描画します。この際、<b>FixedBoxManagerのワールド変換は、アイデンティティ（つまり変換なし）</b>になることに注意してください。<br />
　つまり<b>原点を中心とした座標</b>にすべてのFixedBoxをまとめているのです。<br />
　今回は、FixedBoxクラスは透明になっていませんが、透明を使う場合は注意が必要です。このままでは描画順は原点の位置でカメラからの距離で見ます。ですので、透明にする場合は、<b>描画レイヤーを変更する</b>などして、描画順を制御する必要があります。<br />
<br />
　このようにして最適化すると、しない場合に比べてかなり動作速度が変わります。今回のマップは30×30ですが、これを立方体で表現すると、間違いなく処理落ちが起こります。<br />
<br />
　最適化にはいろんな方法があります。この方法をとれるのは、<b>壁（立方体）が厚さが1個の場合でかつ、高さが1固定</b>、の場合で、縦横高さに自由に伸ばせる場合はこの手法は使えません。<br />
　また、ステージの初期時に位置を決定してしまうので、動くマップの場合は、別の最適化が必要です。<br />
　また、たとえば、<b>オセロの盤</b>のようなマップの場合は、この方法ではあまり意味がありません（描画側は意味があるかもしれませんが）。このような場合は<b>チュートリアル008</b>のような<b>反発する壁</b>を縦横に並べた方が動作速度は速いでしょう。<br />
　また、たとえばカメラから見てある一定上先のオブジェクトは描画しない、という最適化もあります。射影行列の<b>Far位置</b>で調整することも可能ですし、遠くは描画しない代わりに、ぼんやりしたエフェクトを描画する手法もあるでしょう。もちろん、遠くのものは頂点数を減らす、などの最適化もあるでしょう。<br />
<br />
　いずれにせよユーザーに満足してもらうには、<b>軽快な操作感</b>は非常に重要です。どんなに素晴らしいグラフィックでも、<b>操作感</b>に影響を与えては、元も子もありません。<br />
　それぞれのゲームにあった最適化を常に頭に置きながら制作を進めていってもらいたいものです。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="40_03.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="40_05.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
