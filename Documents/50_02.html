<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>５．アルゴリズム研究</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>５０２．Strategy（ストラテジー）を使った、計算アルゴリズムの階層化</h3>
<br />
<h4>Strategy（ストラテジー）とは</h4>
　<b>Strategy（ストラテジー）とは</b>は<b>デザインパターン</b>に含まれるパターンの1つで、アルゴリズムをクラス化します。<br />
　以下の階層図を見てください。
<p>&nbsp;</p>
<img src="img/5002a.jpg" width="100%"/>
<p>図5002a</p>
<p>&nbsp;</p>
　まず、<b>Strategy</b>を親としたクラス階層を記述します。ここにはたとえば<b>Operation()</b>という純粋仮想関数を設けます。<br />
　派生クラスでは、この<b>Operation()</b>を多重定義し、実装します。ここでは、何らかの計算をしてfloatを返す関数として例にとってます。<br />
<br />
　一方、<b>ゲームオブジェクト（Enemyクラスなど）</b>では、この<b>親クラスのポインタ（m_St）</b>を保持しておきます。これはshared_ptrでも生ポインタでも問題ありません。そのポインタをどこかで共有するなら、shared_ptr、newとdeleteを完全管理するなら、生ポインタでも構いません。ようは<b>親クラスのポインタ</b>を保持するのが重要です。<br />
<br />
　実際の実装では、<b>ゲームオブジェクト（Enemyクラスなど）</b>のコンストラクタなどで、このポインタ(m_St)を初期化するか、動的に変更したいなら、動的にnewするなどして、<b>Strategyの派生クラスのポインタ</b>を代入しておきます。<br />
　そして、実装に計算が必要なタイミングで
<div class="box1">
<pre>
float f = m_St->Operation();
</pre>
</div>
　を実行します。<br />
　こうすると、fには、現在代入されている<b>Strategyの派生クラス、すなわち、Low、Middle、High</b>のどれかの<b>Operation()関数</b>が実行されて、その結果が戻ります。<br />
<br />
<h4>Strategy（ストラテジー）の実装例</h4>
　それでは、<b>Sample502</b>を開いて、実行してみてください。<br/>
　実行すると、以下のような画面が現れます。
<img src="img/5002b.jpg" width="80%"/>
<p>図5002b</p>
<p>&nbsp;</p>
　<b>コントローラのA、B、X、Yボタン</b>を押すと、物体がジャンプします。両方ともジャンプしますが、トーラスの方は合わせて回転します。<br />
<br />
　このサンプルは構造がわかりやすいようにかなり単純な設計になってます。<b>図502a</b>における<b>Strategy</b>にあたるクラスが、<b>JumpBaseクラス</b>です。<b>Charactor.h</b>にあります。<br />
　以下が<b>JumpBaseクラス</b>ヘッダです。実装も直接ヘッダ内に記述してあります。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class JumpBase;
    //  用途: ジャンプのアルゴリズムのベースクラス
    //--------------------------------------------------------------------------------------
    class JumpBase{
    protected:
        JumpBase(){}
    public:
        virtual ~JumpBase(){}
        <span class="red">virtual float JumpMethod() = 0;</span>
    };
</pre>
</div>
　この中では、<b>JumpMethod()</b>という純粋仮想関数があり、派生クラスでは、それを多重定義する形になります。<br />
　また、コンストラクタが<b>protected</b>になってます。これは、直接<b>JumpBaseを構築できないようにする</b>ためですが（もともと抽象クラスなので文法的にも構築できないが。。。）、デストラクタは<b>public</b>になってます。<br />
　この理由は、このオブジェクトのポインタを<b>unique_ptr</b>で使う場合、<b>デリータ</b>というのが自動的に動きますが、デストラクタをprotectedにした場合、デリータがアクセスできないためコンパイルエラーになります。このことを避けるために、デストラクタはpublicにしてあります。<br />
<br />
　そして以下は、実際に計算を定義する派生クラスです。<b>JumpShortクラス</b>を例にとります。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class JumpShort : public JumpBase;
    //  用途: 短いジャンプ
    //--------------------------------------------------------------------------------------
    class JumpShort : public JumpBase{
    public:
        JumpShort() :JumpBase(){}
        virtual ~JumpShort(){}
        <span class="red">virtual float JumpMethod()override{
            return 2.0f;
        }</span>
    };
</pre>
</div>
　このように直接float値をリターンしてますが、通常は<b>何らかの計算</b>が行われるでしょう。<br />
<br />
　一方、ゲームオブジェクト側である<b>Box、RollingTorus</b>では、<b>JumpBaseクラスのポインタ</b>を保持します。以下は、<b>Boxクラス</b>の例です。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class Box : public GameObject;
    //  用途: ボックス
    //--------------------------------------------------------------------------------------
    class Box : public GameObject{
        //中略
        <span class="red">unique_ptr&lt;JumpBase> m_JumpStrategy;</span>
    public:
        //中略
    };
</pre>
</div>
　ここで、ポインタを他オブジェクトで共有するわけではないので、<b>unique_ptr</b>として<b>JumpBaseクラスのポインタ</b>を実装しています。<br />
<br />
　実際にジャンプする場合の例を以下にあげます。<b>BoxクラスのUpdate()関数</b>です。
<div class="box1">
<pre>
    //更新
    void Box::Update(){
        //コントローラの取得
        auto CntlVec = App::GetApp()->GetInputDevice().GetControlerVec();
        if (CntlVec[0].bConnected){
            auto PtrGravity = GetComponent&lt;Gravity>();
            if (PtrGravity->GetGravityVelocity().Length() &lt;= 0){
                //地面にいるときのみジャンプできる
                //Aボタンが押された瞬間なら小ジャンプ
                if (CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_A){
                    <span class="red">m_JumpStrategy.reset(new JumpShort());</span>
                    PtrGravity->StartJump(0, m_JumpStrategy->JumpMethod(), 0);
                }
                //Bボタンが押された瞬間なら中ジャンプ
                else if (CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_B){
                    <span class="red">m_JumpStrategy.reset(new JumpMiddle());</span>
                    PtrGravity->StartJump(0, m_JumpStrategy->JumpMethod(), 0);
                }
                //Yボタンが押された瞬間なら大ジャンプ
                else if (CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_Y){
                    <span class="red">m_JumpStrategy.reset(new JumpLong());</span>
                    PtrGravity->StartJump(0, m_JumpStrategy->JumpMethod(), 0);
                }
                //Xボタンが押された瞬間なら大大ジャンプ
                else if (CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_X){
                    <span class="red">m_JumpStrategy.reset(new JumpLongLong());</span>
                    PtrGravity->StartJump(0, m_JumpStrategy->JumpMethod(), 0);
                }
            }
        }
    }
</pre>
</div>
　赤くなっているところが押されたボタンによって、設定する派生クラスを変えています。<br />
　スマートポインタなのでdeleteはする必要がありません。指し替わったタイミングで前のポインタは自動的にdeleteされます。<br />
<br />
<h4>Strategy（ストラテジー）の可能性</h4>
　まず、このサンプルのように、動的に呼び出す計算式を変えることができます。<br />
　また、このサンプルでは<b>BoxとTorus</b>に同じ計算式を当ててますが、<b>BoxとTorus</b>には何の関連性もありません。<b>Strategyは独立したオブジェクト</b>なので、どのオブジェクトで使用することも可能です。<br />
　また、あるオブジェクトが、そのパラメータ（重さとかパワーとか）によって、インスタンス作成時に計算が決定するなら、<b>m_JumpStrategy</b>は<b>コンストラクタやCreate()関数</b>で設定し、ゲーム中同じ計算式を使うことができます。<br />
　また、あるオブジェクトが、ゲーム中、成長やダメージ、あるいは取得したアイテムなどによって、強さ、が変わるのであれば、その<b>強さ</b>を計算するクラスは動的に変更できます。<br />
<br/>
　このように、柔軟に実装できる<b>Strategy（ストラテジー）</b>です。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="50_01.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="50_03.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
