<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３０８．モデルの表示とアニメーション</h3>
<br />
<h4>FBXファイルの表示</h4>
　<b>DxBase2015フレームワーク</b>では、３Ｄモデルのデータとして、<b>Autodesk社のFBXフォーマト</b>を採用しています。セットアップ時に、<b>FBX_SDK</b>のセットアップをする形なので、すでに知ってる方も多いと思います。<br />
　しかしながら、<b>FBX_SDK</b>の仕様は、膨大な情報を扱える形になっていて、すべての機能を実装するのはかなりなハードルとなります。<br />
　また、<b>DxBase2015フレームワーク</b>は<b>３Ｄモデルの詳細な表現</b>を目的とするフレームワークではなく、むしろ、<b>アクション系ゲームのミドルウェア</b>としての位置づけの方が正しいかもしれません。<br />
　つまり、簡単に言えば<b>より細かいモデルの表現より、飛んだり跳ねたりする動きを重視する</b>ゲームのためのフレームワークといえます。<br />
　ですので、これまでのサンプルでは、ただひたすら<b>プリミティブを使用した動きや演出</b>を数多く紹介してきました。まずは、プリミティブだけで動作するゲームを作成し、あとで、プリミティブをモデルに差し替えていく、そんな制作方法を奨励しています。<br />
　以上のことから、<b>FBXファイルの構造</b>にも制約があります。<br />
　以下が主な制約です。
<ul class="mokuji">
<li>ボーンは必ずつながってないといけない。またそのつながりは１つでなければいけない</li>
<li>１つのＦＢＸに複数のメッシュを入れることはできるが、扱うときは、メッシュ単位とする</li>
<li>１つのメッシュが扱うテクスチャは１つが望ましい（複数のテクスチャは扱う機能は実装されてるが、まだ、実験段階）</li>
<li>メッシュのアニメーションラインは１本とする。すなわち、複数のアニメーションを実装する場合、フレーム0から10がアニメーションＡ、11から30までアニメーションＢ、のように、1つのアニメーションラインを分割する。</li>
<li>一つの頂点に複数の法線を持たせることはできない</li>
</ul>
　こうして述べると制約が多いようですが、実際にはＦＢＸを書き出すときに、パラメータに注意すれば制約の多くはクリアできるようです。<br />
<br />
　では、<b>Sample308ディレクトリ</b>のソリューションを開いて、リビルド、実行してみましょう。すると以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/3008a.jpg" width="80%"/>
<p>図3008a</p>
<p>&nbsp;</p>
　これは、<b>チュートリアル007のプレイヤー</b>を、そっくりモデルメッシュに置き換えたものです。衝突判定や、ステアリング、重力コンポーネントもそのままです。<br />
　このモデルは<b>サンプル307同様、WiZの学生さん</b>が作成したものです。特定のゲーム用に作成したので、汎用的なサンプルとしては向いてないかもしれませんが、原理だけわかればよいかと思います。<br />
<br />
　コントローラを動かせば、アニメーションが変わり、動きは<b>チュートリアル007のプレイヤー</b>のままです。Ａボタンでジャンプしますし、ボックスの上にも乗れます。<br/>
<br />
　それでは、コードを紹介します。<br />
　まず最初に行うことは、<b>FBXシーンとメッシュリソース</b>を作成し、それをリソース化することです。<br />
　<b>GameStage.cppのGameStage::CreateResourses()関数</b>で行います。以下がそのピックアップです。
<div class="box1">
<pre>
    void GameStage::CreateResourses(){

        //中略

        <span class="red">//FBXメッシュファイルからFBXファイル全体のオブジェクトの作成登録
        //赤いキャラ
        auto DataDir = App::GetApp()->m_wstrRelativeDataPath + L"Chara_R\\";
        auto PtrFbxScene = App::GetApp()->RegisterFbxScene(L"CHARA_R_FBX", DataDir, L"Chara_R.fbx");
        auto PtrFbxMesh = App::GetApp()->RegisterFbxMesh(L"CHARA_R_MESH", PtrFbxScene, 0);
        PtrFbxMesh->AddAnimation("wait", 5, 4, true, 10);
        PtrFbxMesh->AddAnimation("walk", 13, 4, true, 10);

        //青いキャラ
        DataDir = App::GetApp()->m_wstrRelativeDataPath + L"Chara_B\\";
        PtrFbxScene = App::GetApp()->RegisterFbxScene(L"CHARA_B_FBX", DataDir, L"Chara_B.fbx");
        PtrFbxMesh = App::GetApp()->RegisterFbxMesh(L"CHARA_B_MESH", PtrFbxScene, 0);
        PtrFbxMesh->AddAnimation("wait", 5, 4, true, 10);
        PtrFbxMesh->AddAnimation("walk", 13, 4, true, 10);</span>

    }
</pre>
</div>
　実際に表示されているのは赤いキャラのみですが、青いキャラクタもデータが実装されているので、ここで読み込んでおきます。<br />
　上記ソースのポイントは
<div class="box1">
<pre>
        //FBXメッシュファイルからFBXファイル全体のオブジェクトの作成登録
        //赤いキャラ
        auto DataDir = App::GetApp()->m_wstrRelativeDataPath + L"Chara_R\\";
        auto PtrFbxScene = App::GetApp()->RegisterFbxScene(L"CHARA_R_FBX", DataDir, L"Chara_R.fbx");</pre>
</div>
　で<b>FBXシーンの登録</b>を行っています。<b>FBXシーン</b>は、動的に参照することも少ないですが、リソースとして登録することで、ステージが再読み込みされるときなどにストレスなく配置できます。<br />
　その後
<div class="box1">
<pre>
        auto PtrFbxMesh = App::GetApp()->RegisterFbxMesh(L"CHARA_R_MESH", PtrFbxScene, <span class="red">0</span);
</pre>
</div>
　は、FBXシーンの中からメッシュを取り出し、それをリソース化しておきます。赤くなってるところは、<b>FBXシーンの0番目のメッシュ</b>という意味です。<br />
　その後アニメーションの登録を行います。
<div class="box1">
<pre>
        PtrFbxMesh->AddAnimation("wait", 5, 4, true, 10);
        PtrFbxMesh->AddAnimation("walk", 13, 4, true, 10);
</pre>
</div>
　<b>AddAnimation()関数</b>の引数は、<b>アニメーション名（string型で指定）、開始フレーム、フレーム数、ループするかどうか、再生スピード（30がデフォルト）</b>です。一つ一つが小さいアニメーションなので、少しゆっくり再生するようにしてあります（フレーム間は自動補間されます）。<br />
　このようにして2つのアニメーションを登録しておきます。<br />
<br/>
　実際の実装は、<b>Player,cpp</b>で行います、以下は<b>Create()関数</b>です。
<div class="box1">
<pre>
    //初期化
    void Player::Create(){
        //中略

        //モデルの相対スケール
        //モデル自体は大きいので、ステージに合わせて小さくする
        Matrix4X4 CharaScale;
        CharaScale.DefTransformation(
            Vector3(0.01f, 0.01f, 0.01f),
            Vector3(0.0f, XM_PI, 0.0f),
            Vector3(0.0f, -0.5f, 0.0f)
            );

        //影をつける
        auto ShadowPtr = AddComponent&lt;Shadowmap>();
        <span class="red">ShadowPtr->SetMeshResource(L"CHARA_R_MESH");</span>
        ShadowPtr->SetMeshToTransform(CharaScale);

        <span class="red">auto PtrDraw = AddComponent&lt;BasicFbxPNTBoneDraw>();
        PtrDraw->SetMeshToTransform(CharaScale);
        PtrDraw->SetFbxMeshResource(L"CHARA_R_MESH");
        PtrDraw->SetCurrentAnimation("wait");
        PtrDraw->SetTextureOnlyNoLight(true);</span>

        //中略
    }
</pre>
</div>
　ここでは、描画コンポーネントを<b>BasicFbxPNTBoneDraw</b>というコンポーネントにします。これは、<b>ボーン付のFBXメッシュの描画</b>という意味です。また、モデルと実際のステージの単位系の違いを吸収するために、SetMeshToTransform()で、変換行列を渡します。メッシュは、リソース登録してある<b>CHARA_R_MESH</b>を渡します。そして、最初のアニメーションを、<b>SetCurrentAnimation()関数</b>で指定します。<br />
　<b>SetTextureOnlyNoLight()関数</b>は、ライティングの影響を受けない、設定です。こうしておくとライティングの影響を受けずに、作成された状態に近いモデル表示になります。逆にこれを指定しないとライティングの影響を受けますので、暗い場合は暗く、明るい場合は、うすい色になります。<br />
<br />
　あとは、状態によるアニメーションの切り替えです。簡略化するために、一定以上の速度なら<b>walk</b>以内なら、<b>wait</b>を設定します。それは、<b>Update2()関数</b>で行ってます。
<div class="box1">
<pre>
    void Player::Update2(){
        //中略

        auto PtrRedit = GetComponent&lt;Rigidbody>();
        auto PtrDraw = GetComponent&lt;BasicFbxPNTBoneDraw>();
        if (PtrRedit->GetVelocity().Length() > 0.5f){
            if (PtrDraw->GetCurrentAnimation() != "walk"){
                PtrDraw->SetCurrentAnimation("walk");
            }
        }
        else{
            if (PtrDraw->GetCurrentAnimation() != "wait"){
                PtrDraw->SetCurrentAnimation("wait");
            }
        }

        //中略

    }
</pre>
</div>
　こんな感じです。<br />
　また、このサンプルでは青いモデル、も読み込んでますが、その場合、<b>CHARA_R_MESH</b>を<b>CHARA_B_MESH</b>にすれば、青いメッシュになります。<br />
<br />
<h4>アニメーションをしない場合の設定</h4>
　ここまで、ボーンアニメーションが入っているモデルの表示を紹介しましたが、アニメーションを使用しない例として
<div class="box1">
<pre>
１、ボーンの入っていないモデルの表示の場合
２、ボーンは入っているが意図的にアニメーションしない場合
</pre>
</div>
　の2つのケースが考えられます。<br />
　このサンプルで紹介するのは２のケースですが、１も２も設定は同じです。<br />
　<b>PlayerのCreate()関数</b>で、実装する描画コンポーネントを変更します。
<div class="box1">
<pre>
    void Player::Create(){
        //中略

        <span class="red">auto PtrDraw = AddComponent&lt;BasicFbxPNTDraw>();</span>
        PtrDraw->SetMeshToTransform(CharaScale);
        PtrDraw->SetFbxMeshResource(L"CHARA_R_MESH");
        //PtrDraw->SetCurrentAnimation("wait");
        PtrDraw->SetTextureOnlyNoLight(true);

        //中略

    }
</pre>
</div>
　そして、Update2()関数で、先ほど記述したアニメーションの切り替えをコメントにします。
<div class="box1">
<pre>
    void Player::Update2(){
        //中略

        //auto PtrRedit = GetComponent&lt;Rigidbody>();
        //auto PtrDraw = GetComponent&lt;BasicFbxPNTBoneDraw>();
        //if (PtrRedit->GetVelocity().Length() > 0.5f){
        //  if (PtrDraw->GetCurrentAnimation() != "walk"){
        //      PtrDraw->SetCurrentAnimation("walk");
        //  }
        //}
        //else{
        //  if (PtrDraw->GetCurrentAnimation() != "wait"){
        //      PtrDraw->SetCurrentAnimation("wait");
        //  }
        //}

        //中略

    }
</pre>
</div>
　これで、以下のような画面になります。
<p>&nbsp;</p>
<img src="img/3008b.jpg" width="80%"/>
<p>図3008b</p>
<p>&nbsp;</p>
　これはおなじみ<b>Tポーズ</b>という、<b>ボーンアニメーションのメッシュの基本形</b>です。<br />
　実際Tポーズをゲーム上で表示させるかどうかはともかく、描画コンポーネントを変えるだけで、アニメーションのしないFBXメッシュを表示することは可能です。<br />
　上記、<b>１のケース（ボーンの入っていないモデルの表示の場合）</b>も<b>BasicFbxPNTDrawコンポーネント</b>を実装することで表示できます。<br />
<br />
　<b>FBXファイルの読み込み</b>は<b>デバッグモード時</b>に遅くなります。<br />
　これは<b>FBX_SDKの仕様</b>と思われますが、しかし<b>リリースモード</b>で<b>リビルド</b>すれば、かなり読み込みは速くなります。通常、ゲームを誰かに遊んでもらう場合、デバッグモードというのは考えられないので、必ず<b>リリースモード</b>でコンパイルしたものを配布しましょう。<br />
　その場合、<b>リリースモード</b>では<b>必ずリビルド</b>をしてください。<br />
<br />
　また、どうしても、ライブラリに含まれるFBXファイル実装で不満の場合は、完全自作の形になりますが、方法はあります。<br />
　その場合、ライブラリ内<b>BaseResource.cpp内</b>の<b>FbxMeshResourceクラス</b>は参考になるでしょう。<br />
　表示は、この項で紹介した、<b>BasicFbxPNTBoneDraw、BasicFbxPNTDrawコンポーネント</b>が参考になるでしょう。<br />
　シェーダも自作するようになると思いますが、それは<b>頂点シェーダとピクセルシェーダの自作サンプル</b>で紹介します。

<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="30_07.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
