<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>シンプルDxBase2015</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>Simple04．３Ｄオブジェクトのテクスチャ描画</h3>
<br />
<h4>テクスチャの読み込み</h4>
　<b>DxBase2015Simple/Simple04</b>のソリューションを開いて、リビルド、実行しますと以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/Simple04a.jpg" width="80%"/>
<p>図Simple04a</p>
<p>&nbsp;</p>
　前項では、頂点に色を付けてグラデーションを表現していましたが、今項では<b>テクスチャ</b>を実装します。<br />
　DirectX11では、テクスチャは<b>シェーダーリソースビュー</b>という形で表現します。つまり、テクスチャファイル（画像ファイル）を、<b>シェーダーリソースビュー</b>に読み込む処理が必要ですが、ここに、マイクロソフト社のユーティリティである<b>DirectXTex</b>を利用します。<br />
　<b>シェーダーリソースビュー</b>は<b></b>
<div class="box1">
<pre>
        //シェーダリソースビュー（テクスチャリソース）
        ComPtr&lt;ID3D11ShaderResourceView> m_ShaderResView;
</pre>
</div>
　という形で、<b>GameObjectのメンバ</b>として設置しておきます。<br/>
　読み込んでいる記述は以下です。<b>GameObject::CreateShaderResView()関数</b>です。
<div class="box1">
<pre>
    void GameObject::CreateShaderResView(){
        //テクスチャ作成
        DirectX::TexMetadata metadata;
        DirectX::ScratchImage image;
        ThrowIfFailed(
            DirectX::LoadFromWICFile(m_TextureFileName.c_str(), 0, &metadata, image),
            L"テクスチャの読み込みに失敗しました",
            m_TextureFileName,
            L"GameObject::CreateShaderResView()"
            );
        //デバイスとコンテキストインターフェイスの取得
        //デバイスの取得
        auto Dev = App::GetApp()->GetDeviceResources();
        ID3D11Device* pDx11Device = Dev->GetD3DDevice();
        ID3D11DeviceContext* pID3D11DeviceContex = Dev->GetD3DDeviceContext();
        //ミューテックス
        std::mutex Mutex;
        Util::DemandCreate(m_ShaderResView, Mutex, 
            [&](ID3D11ShaderResourceView** pResult) -> HRESULT
        {
            // 画像からシェーダリソースViewの作成
            return ThrowIfFailed(
                CreateShaderResourceView(pDx11Device, 
                    image.GetImages(), 
                    image.GetImageCount(), 
                    metadata, 
                    pResult),
                L"シェーダーリソースビューを作成できません",
                L"if( FAILED( CreateShaderResourceView() ) )",
                L"Texture::Impl::Impl()"
                );
        });
    }
</pre>
</div>
　ここでは、<b>DirectX::LoadFromWICFile()</b>というDirectxTexの関数で読み込んでいます。JPEG、PNG、ビットマップなどはこの方法で読み込めます。<b>TGAファイル</b>の場合は<b>LoadFromTGAFile()</b>、<b>DDSファイル</b>の場合は、<b>LoadFromDDSFile()</b>を利用してください。<br />
<br />
<h4>ピクセルシェーダ</h4>
　<b>シェーダーリソースビュー</b>が作成出来たら、シェーダを作成します。今回は、テクスチャをシェーダに取り込みますので、ピクセルシェーダに<b>Texture2D</b>というオブジェクトと、<b>サンプラー</b>を実装します。以下がピクセルシェーダです。
<div class="box1">
<pre>
#include "PRTexture3D.hlsli"

<span class="red">Texture2D&lt;float4> SimpleTexture : register(t0);
SamplerState SimpleSampler : register(s0);</span>


//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------
float4 main(PixelShaderInput input) : SV_TARGET
{
    //ライトの向きを得る
    float3 LightDirection = normalize(float3(LightDir.xyz));
    float3 InputNormal = normalize(input.Normal);
    //ライトによるピクセルの色を決定
    float4 LightColor = saturate(dot(InputNormal, LightDirection) + float4(0.7, 0.7, 0.7, 1.0));
    //ライトの透明処理はなし
    LightColor.a = 1;
    //テクスチャと合わせる
    float4 TextureColor = SimpleTexture.Sample(SimpleSampler, input.TexCoord);
    //テクスチャ色とライト色を合成
    return TextureColor *LightColor;
}
</pre>
</div>
　赤くなっているところがテクスチャとサンプラーです。<br />
　頂点シェーダと、インクルードファイルも前項からは少し変更がありますので注意してください。<br />
<br />
　描画は、前項との大きな違いはテクスチャとサンプラーを実装するところ、そして、頂点のストライドを今項の頂点形式に合わせるところです。
<div class="box1">
<pre>
    void GameObject::Draw(){
        //中略

        //ストライドとオフセット
        UINT stride = sizeof(VertexPositionNormalTexture);
        UINT offset = 0;
        //頂点バッファの設定
        pID3D11DeviceContext->IASetVertexBuffers(0, 1, 
            m_VertexBuffer.GetAddressOf(), &stride, &offset);
        //中略

        //塗りつぶし処理（今回の画像はJPEGなので透明にしない）
        pID3D11DeviceContext->OMSetBlendState(RenderStatePtr->GetOpaque(), 
            nullptr, 0xffffffff);

        //中略

        //リニアサンプラーを設定
        ID3D11SamplerState* samplerState = RenderStatePtr->GetLinearClamp();
        pID3D11DeviceContext->PSSetSamplers(0, 1, &samplerState);
        //テクスチャを設定
        pID3D11DeviceContext->PSSetShaderResources(0, 1, m_ShaderResView.GetAddressOf());

        //中略

    }
</pre>
</div>
　細かいところは、前項と違いますが、各自確認してください。
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="Simple_03.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="Simple_05.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
