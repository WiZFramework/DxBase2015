<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>４．独自の頂点と独自描画</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>４０５．頂点を自作する２</h3>
　この項では、前項のサンプルをさらに進化させて、様々な頂点操作を実装します。<br />
　主な実装は<b>使いまわしできるシェーダの作成、影（シャドウマップ）のカスタマイズ、頂点フォーマットの変更</b>です。<br />
　<b>DxBase2015</b>の持つ<b>メッシュと頂点シェーダ、ピクセルシェーダを使用したカスタマイズ</b>のいわば終着点ともいえます。<br />
　このサンプルを応用するといろんなゲーム特有の表現が可能になります。ぜひ、目を通していただいて、<b>DxBase2015</b>が<b>どのようにDirectX11のインターフェイスを提供するのか</b>を体験していただければと思います。<br />
<br />
<h4>このサンプルの概要</h4>
　このサンプルでは、まず３つの<b>正8面体オブジェクト</b>を作成します。このオブジェクトは<b>DxBase2015</b>に含まれるユーティリティ関数によって作成されます。しかし、それで作成されたメッシュは<b>VertexPositionNormalTexture</b>フォーマットなので、それを<b>VertexPositionNormalColor</b>フォーマットに変更します。<br />
　そうしてできたメッシュを、独自のシェーダで描画します。しかし、オブジェクトが複数あるので、これまでのように<b>シェーダーは各オブジェクトが保持するのではなく、シングルトンとして</b>再利用できるようにします。<br />
　また<b>影（シャドウマップ）</b>も、デフォルトでは、<b>VertexPositionNormalTexture</b>フォーマットでの描画なので、<b>コンポーネント派生クラス</b>を作り、<b>独自の影描画</b>を行います。この際、<b>影（シャドウマップ）</b>にも<b>使いまわしができるシェーダ</b>を使用します。<br />
　<b>VertexPositionNormalColor</b>は頂点に色を付けられます。各頂点の色が違えば<b>DirectX11は自動的にグラデーション処理</b>をしてくれます。その値と、ライティングによる影響を加味して、オブジェクトを描画します。<br />
<br />
　ざっと概要を説明しましたが、まずは、<b>Sample406ディレクトリ</b>のソリューションを開き、リビルド実行してください。すると以下のような画面が出ます。
<p>&nbsp;</p>
<img src="img/4006a.jpg" width="60%"/>
<p>図4006a</p>
<p>&nbsp;</p>
　画面を見るとわかる通り、3つのオブジェクト（正8面体）が配置されています。半分より上の部分が伸び縮みします。オブジェクトの上下に近い部分は若干透けています。プレイヤーをオブジェクトの奥に移動させて、透かして見ることもできます。<br />
<br />
<h4>メッシュの作成</h4>
　まず、メッシュの作成から見ていきましょう。<b>Character.cpp</b>の<b>CustomDrawOctahedron::CreateCustomMesh()</b>に記述があります。
<div class="box1">
<pre>
    void CustomDrawOctahedron::CreateCustomMesh(){
        vector&lt;VertexPositionNormalTexture> vertices;
        vector&lt;uint16_t> indices;
        //正8面体の作成
        <span class="red">VertexUtil::CreateOctahedron(1.0f, vertices, indices);</span>
        m_BackupVirtex.clear();
        for (auto V : vertices){
            Color4 Col;
            if (V.position.y > 0){
                switch (m_Pattern){
                case 0:
                    Col = Color4(1.0f, 0.0f, 0.0f, 0.0f);
                    break;
                case 1:
                    Col = Color4(0.0f, 1.0f, 0.0f, 0.0f);
                    break;
                case 2:
                    Col = Color4(0.0f, 0.0f, 1.0f, 0.0f);
                    break;
                default:
                    Col = Color4(1.0f, 1.0f, 1.0f, 1.0f);
                    break;
                }
            }
            else if (V.position.y &lt; 0){
                switch (m_Pattern){
                case 0:
                    Col = Color4(0.0f, 1.0f, 0.0f, 0.0f);
                    break;
                case 1:
                    Col = Color4(0.0f, 0.0f, 1.0f, 0.0f);
                    break;
                case 2:
                    Col = Color4(1.0f, 0.0f, 0.0f, 0.0f);
                    break;
                default:
                    Col = Color4(1.0f, 1.0f, 1.0f, 1.0f);
                    break;
                }
            }
            else{
                Col = Color4(1.0f, 1.0f, 1.0f, 1.0f);
            }
            m_BackupVirtex.push_back(
                VertexPositionNormalColor(V.position, V.normal, Col)
            );
        }
        //ミューテックス
        std::mutex Mutex;
        //デバイスの取得
        auto Dev = App::GetApp()->GetDeviceResources();
        ID3D11Device* pDx11Device = Dev->GetD3DDevice();
        <span class="red">//バッファの作成
        Util::DemandCreate(m_VertexBuffer, Mutex, [&](ID3D11Buffer** pResult)
        {
            //頂点バッファの作成(頂点変更可能)
            VertexUtil::CreateDynamicPrimitiveVertexBuffer(pDx11Device, m_BackupVirtex, pResult);
        });
        //頂点数の設定
        m_NumVertices = static_cast&lt;UINT>(vertices.size());
        Util::DemandCreate(m_IndexBuffer, Mutex, [&](ID3D11Buffer** pResult)
        {
            //インデックスバッファの作成
            VertexUtil::CreatePrimitiveBuffer(pDx11Device, indices, D3D11_BIND_INDEX_BUFFER, pResult);
        });
        //インデックス数の設定
        m_NumIndicis = static_cast&lt;UINT>(indices.size());</span>
    }
</pre>
</div>
　ここではまず、
<div class="box1">
<pre>
        //正8面体の作成
        <span class="red">VertexUtil::CreateOctahedron(1.0f, vertices, indices);</span>
</pre>
</div>
　で、正8面体を作成します。しかし作成される頂点の配列は<b>VertexPositionNormalTexture型</b>の配列なので、これを<b>VertexPositionNormalColor型</b>に変換します。<br />
　<b>m_BackupVirtex</b>というのは、メンバの配列で、<b>VertexPositionNormalColor型</b>の配列です。ここに変換した頂点の配列を保持します。この際、コンストラクタの引数で与えられたパターンに合わせ、頂点色を決定します。<br />
　頂点とインデックスの配列が出来ましたら、これをもとに、<b>頂点バッファとインデックスバッファ</b>を作成します。以下は頂点バッファの作成です。
<div class="box1">
<pre>
        Util::DemandCreate(m_VertexBuffer, Mutex, [&](ID3D11Buffer** pResult)
        {
            //頂点バッファの作成(頂点変更可能)
            VertexUtil::CreateDynamicPrimitiveVertexBuffer(pDx11Device, m_BackupVirtex, pResult);
        });
</pre>
</div>
　ここで呼ばれている、<b>Util::DemandCreate()</b>は<b>ラムダ式の呼び出し関数（テンプレート関数）</b>です。<b>m_VertexBufferが無効だった場合に</b>安全に作成してくれます。<b>Mutex</b>を渡しているのは、内部でロックをかけるためです。<br />
　このようにして作成された、<b>m_VertexBuffer、m_IndexBuffer</b>と、頂点数、インデックス数をそれぞれメンバ変数に代入して、メッシュの作成は終了です。<br />
<br />
<h4>シェーダの作成</h4>
　ここでは<b>頂点シェーダとピクセルシェーダ</b>を使用しますが、前項までと違い、<b>シェーダはインスタンス内に持ちません。</b>なぜなら、それぞれのシェーダの処理は同じなので、オブジェクトごとに持つと無駄が生じるからです。<b>DxBase2015</b>では、このように使いまわしができるシェーダを<b>シングルトン</b>として作成する機能があります。<br />
　以下がそのシェーダークラスのヘッダです。<b>頂点、ピクセル両シェーダ、そしてコンスタントバッファ</b>も、シングルトンとして作成します。
<div class="box1">
<pre>
    //カスタム描画コンスタントバッファ構造体
    struct CustomDrawConstantBuffer
    {
        Matrix4X4 World;
        Matrix4X4 View;
        Matrix4X4 Projection;
        Vector4 LightDir;
        Vector4 Param;  //汎用パラメータ
        CustomDrawConstantBuffer() {
            memset(this, 0, sizeof(CustomDrawConstantBuffer));
        };
    };
    //--------------------------------------------------------------------------------------
    //  class CBCustomDraw : public ConstantBuffer&lt;CBCustomDraw,CustomDrawConstantBuffer>;
    //  用途: カスタムコンスタントバッファ
    //--------------------------------------------------------------------------------------
    class CBCustomDraw : public ConstantBuffer&lt;CBCustomDraw, CustomDrawConstantBuffer>{
    };

    //--------------------------------------------------------------------------------------
    //  class VSCustomDraw : public VertexShader&lt;VSCustomDraw, VertexPositionNormalColor>;
    //  用途: VSCustomDraw頂点シェーダ
    //--------------------------------------------------------------------------------------
    class VSCustomDraw : public VertexShader&lt;VSCustomDraw, VertexPositionNormalColor>{
    public:
        //構築
        VSCustomDraw();
    };
    //--------------------------------------------------------------------------------------
    //  class PSCustomDraw : public PixelShader&lt;PSCustomDraw>;
    //  用途: PSCustomDrawピクセルシェーダ
    //--------------------------------------------------------------------------------------
    class PSCustomDraw : public PixelShader&lt;PSCustomDraw>{
    public:
        //構築
        PSCustomDraw();
    };
</pre>
</div>
　こうしてみると、ほとんど骨組みだけヘッダに記述されることがわかります。<b>コンスタントバッファ構造体</b>は前項では、クラス内に宣言がありましたが、使いまわしする場合、外に出します。<br />
　続いて<b>Character.cppファイル</b>ですが、以下のように記述します。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class CBCustomDraw : public ConstantBuffer&lt;CBCustomDraw,CustomDrawConstantBuffer>;
    //  用途: カスタムコンスタントバッファ
    //--------------------------------------------------------------------------------------
    //シングルトン処理
    unique_ptr&lt;CBCustomDraw, CBCustomDraw::Deleter> CBCustomDraw::m_Ptr;
    //--------------------------------------------------------------------------------------
    //  class VSCustomDraw : public VertexShader&lt;VSCustomDraw, VertexPositionNormalColor>;
    //  用途: VSCustomDraw頂点シェーダ
    //--------------------------------------------------------------------------------------
    //シングルトン処理
    unique_ptr&lt;VSCustomDraw, VSCustomDraw::Deleter> VSCustomDraw::m_Ptr;
    //構築
    VSCustomDraw::VSCustomDraw() :
        VertexShader(App::GetApp()->m_wstrRelativeShadersPath + L"VSSimpleBase.cso")
    {}
    //--------------------------------------------------------------------------------------
    //  class PSCustomDraw : public PixelShader&lt;PSCustomDraw>;
    //  用途: PSCustomDrawピクセルシェーダ
    //--------------------------------------------------------------------------------------
    unique_ptr&lt;PSCustomDraw, PSCustomDraw::Deleter> PSCustomDraw::m_Ptr;
    //構築
    PSCustomDraw::PSCustomDraw() :
        PixelShader(App::GetApp()->m_wstrRelativeShadersPath + L"PSSimpleBase.cso")
    {}
</pre>
</div>
　ここでは、シングルトンのため、各statuc変数の実体を記述します。<br />
　また、頂点シェーダとピクセルシェーダは、シェーダファイル名をコンストラクタで設定しています。<br />　この処理で、シェーダとコンスタントバッファは共有で使用できるようになります。<br />
<br />
<h4>シェーダの使用</h4>
　このようにして作成したシェーダやコンスタントバッファは<b>static呼び出し</b>で使用できるようになります。具体的には<b>Draw()関数</b>に記載があります。赤くなっているところが、ststic呼び出しをおこなっているところです。
<div class="box1">
<pre>
    void CustomDrawOctahedron::Draw(){
        //中略

        //コンスタントバッファの設定
        CustomDrawConstantBuffer cb1;
        //行列の設定(転置する)
        cb1.World = Matrix4X4EX::Transpose(PtrT->GetWorldMatrix());;
        cb1.View = Matrix4X4EX::Transpose(View);
        cb1.Projection = Matrix4X4EX::Transpose(Proj);
        //ライトの設定
        //ステージから0番目のライトを取り出す
        auto PtrLight = GetStage()->GetTargetLight(0);
        cb1.LightDir = PtrLight->GetDirectional();
        cb1.LightDir.w = 1.0f;

        //コンスタントバッファの更新
        <span class="red">pID3D11DeviceContext->UpdateSubresource(
            CBCustomDraw::GetPtr()->GetBuffer(), 0, nullptr, &cb1, 0, 0);</span>
        //ストライドとオフセット
        UINT stride = sizeof(VertexPositionNormalColor);
        UINT offset = 0;
        //頂点バッファの設定
        pID3D11DeviceContext->IASetVertexBuffers(0, 1, m_VertexBuffer.GetAddressOf(), &stride, &offset);
        //インデックスバッファのセット
        pID3D11DeviceContext->IASetIndexBuffer(m_IndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0);
        //描画方法（3角形）
        pID3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
        //ステータスのポインタ
        //テクスチャを取得
        ID3D11ShaderResourceView* pNull[1] = { 0 };
        ID3D11SamplerState* pNullSR[1] = { 0 };
        //半透明処理
        pID3D11DeviceContext->OMSetBlendState(RenderStatePtr->GetAlphaBlendEx(), nullptr, 0xffffffff);
        //デプスステンシルは使用する
        pID3D11DeviceContext->OMSetDepthStencilState(RenderStatePtr->GetDepthDefault(), 0);
        //シェーダの設定
        <span class="red">pID3D11DeviceContext->VSSetShader(VSCustomDraw::GetPtr()->GetShader(), nullptr, 0);
        pID3D11DeviceContext->PSSetShader(PSCustomDraw::GetPtr()->GetShader(), nullptr, 0);
        //インプットレイアウトの設定
        pID3D11DeviceContext->IASetInputLayout(VSCustomDraw::GetPtr()->GetInputLayout());
        //コンスタントバッファの設定
        ID3D11Buffer* pConstantBuffer = CBCustomDraw::GetPtr()->GetBuffer();</span>
        pID3D11DeviceContext->VSSetConstantBuffers(0, 1, &pConstantBuffer);
        pID3D11DeviceContext->PSSetConstantBuffers(0, 1, &pConstantBuffer);

        //中略

    }
</pre>
</div>
　これで、シェーダを再利用して描画することができます。<br />
　なお、<b>頂点シェーダ、ピクセルシェーダ（HLSLファイル）</b>も前項とは書き換わってますので確認してください。（<b>VertexPositionNormalColor型</b>用のものになってます）。<br />
<br />
<h4>影（シャドウマップ）の自作</h4>
　各GameObjectに、<b>Shadowmapコンポーネント</b>を追加すると、影を出す（受ける方ではない）ことができるのはこれまでも実装してきました。<br />
　しかし、デフォルトの<b>Shadowmapコンポーネント</b>は、<b>VertexPositionNormalTexture型</b>のメッシュリソース用のものであり、今回のような<b>VertexPositionNormalColor型</b>のメッシュには利用できません。しかし、<b>Shadowmapコンポーネントの派生クラス</b>を作り、その<b>Draw()関数</b>を多重定義することにより、独自の影描画を実装することができます。<br />
　以下が、<b>Shadowmapコンポーネントの派生クラスである、CustomShadowmapクラスのヘッダ</b>です。
<div class="box1">
<pre>
    class CustomShadowmap : public Shadowmap{
    public:
        explicit CustomShadowmap(const shared_ptr&lt;GameObject>& GameObjectPtr);
        virtual ~CustomShadowmap();
        //操作
        virtual void Draw();

    };
</pre>
</div>
　このように簡素なものです。<b>Draw()が多重定義</b>されているのがわかります。<br/>
　以下が、<b>Draw()</b>の実体です
<div class="box1">
<pre>
    void CustomShadowmap::Draw(){
        //m_GameObjectがnullならDrawできない
        if (IsGameObjectActive()){
            auto PtrGameObject = GetGameObject();
            auto PtrStage = PtrGameObject->GetStage();
            if (!PtrStage){
                return;
            }
            auto PtrT = PtrGameObject->GetComponent&lt;Transform>();
            //ステージから0番目のライトを取り出す
            auto PtrLight = PtrStage->GetTargetLight(0);
            //ステージからカメラを取り出す
            auto PtrCamera = PtrStage->GetTargetCamera();

            if (PtrT && PtrLight && PtrCamera){

                Matrix4X4 RealWorldMatrix = GetMeshToTransform() * PtrT->GetWorldMatrix();


                auto Dev = App::GetApp()->GetDeviceResources();
                auto pID3D11DeviceContext = Dev->GetD3DDeviceContext();
                //ステータスのポインタ
                auto RenderStatePtr = PtrStage->GetRenderState();


                //ライトの取得
                Matrix4X4 LightView, LightProj;

                Vector3 LightDir = -1.0 * PtrLight->GetDirectional();
                Vector3 LightAt = PtrCamera->GetAt();
                Vector3 LightEye = LightAt + (LightDir * GetLightHeight());

                //ライトのビューと射影を計算
                LightView.LookAtLH(LightEye, LightAt, Vector3(0, 1.0f, 0));
                LightProj.OrthographicLH(
                    GetViewWidth(), GetViewHeight(), GetLightNear(), GetLightFar());
                CustomShadowmapConstantBuffer Cb;
                Cb.mWorld = Matrix4X4EX::Transpose(RealWorldMatrix);
                Cb.mView = Matrix4X4EX::Transpose(LightView);
                Cb.mProj = Matrix4X4EX::Transpose(LightProj);
                //これより描画処理
                //コンスタントバッファの更新
                pID3D11DeviceContext->UpdateSubresource(
                    CBCustomShadowmap::GetPtr()->GetBuffer(), 0, nullptr, &Cb, 0, 0);
                //インプットレイアウトのセット
                pID3D11DeviceContext->IASetInputLayout(
                    VSCustomShadowmap::GetPtr()->GetInputLayout());
                //ストライドとオフセット
                UINT stride = sizeof(VertexPositionNormalColor);
                UINT offset = 0;

                auto GameObj = dynamic_pointer_cast&lt;CustomDrawOctahedron>(GetGameObject());
                //頂点バッファをセット
                pID3D11DeviceContext->IASetVertexBuffers(
                    0, 1, GameObj->GetVertexBuffer().GetAddressOf(), &stride, &offset);
                //頂点シェーダーのセット
                pID3D11DeviceContext->VSSetShader(
                    VSCustomShadowmap::GetPtr()->GetShader(), nullptr, 0);
                //インデックスバッファのセット
                pID3D11DeviceContext->IASetIndexBuffer(
                    GameObj->GetIndexBuffer().Get(), DXGI_FORMAT_R16_UINT, 0);
                //描画方法（3角形）
                pID3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

                //ピクセルシェーダはセットしない！
                pID3D11DeviceContext->PSSetShader(nullptr, nullptr, 0);
                //ジオメトリシェーダの設定（使用しない）
                pID3D11DeviceContext->GSSetShader(nullptr, nullptr, 0);

                //コンスタントバッファの設定
                ID3D11Buffer* pConstantBuffer = CBCustomShadowmap::GetPtr()->GetBuffer();
                pID3D11DeviceContext->VSSetConstantBuffers(0, 1, &pConstantBuffer);
                ID3D11Buffer* pNullConstantBuffer = nullptr;
                //コンスタントバッファをピクセルシェーダにセット
                pID3D11DeviceContext->PSSetConstantBuffers(0, 1, &pNullConstantBuffer);
                //描画
                pID3D11DeviceContext->DrawIndexed(GameObj->GetNumIndicis(), 0, 0);
                //後始末
                Dev->InitializeStates(RenderStatePtr);

            }

        }
    }
</pre>
</div>
　ここでも、オブジェクト同様シェーダを使いまわしてます。記載されてますので確認ください。<br />
　<b>シャドウマップ</b>というのは、<b>ステンシルバッファ</b>という特別な領域に、<b>ライト方向から見たオブジェクト</b>を描画します。<b>描画領域をステンシルバッファにする</b>処理は、この関数が呼ばれる以前にフレームワークによって設定されてますので、気にする必要はありません。<br />
　ようは、ここでは<b>ライトをカメラに見立てて、ライトから見たオブジェクト</b>を描画すればよいのです。ですから、ワールド行列やビュー、射影行列は、ライト方向から見た行列になります。<br/>
　ライトはステージから取り出します。つまり0万めのライトです。<br />
　また、シャドウマップはピクセルシェーダは必要ありません。ポジションをそのままスルーすればよいのです。<br />
<br/>
　実際の影の描画は、<b>影を受け取る側</b>で描画します。このサンプルでは<b>プレート</b>です。<br />
　プレートで<b>DrawComp->SetOwnShadowActive(true);</b>のように設定されているのがわかると思います。<br />
　このフラグが立っていると、<b>フレームワークに用意されたDrawコンポーネント</b>は、プレート描画用のシェーダでステンシルバッファとの合成を行います。<br />
　今回のサンプルのオブジェクトも<b>影を受け取るように</b>記述することは可能ですが、行っていません。そのためには、シェーダを対応するように記述しなければいけません。<br />
　<b>影を出す側（シャドウマップ）</b>は、どんどん記述してもいいのですが、<b>影を受け取る側</b>は、あまり書きすぎると、オブジェクトが目立たなくなったりしますので、最低限でよいと思います。<br />
　もし、記述したければ、フレームワーク内のピクセルシェーダ<b>PSBasicPNT.hlslやPSSimplePNT2.hlsl</b>などを参考にしてください。<br/>
<br />
　この項のサンプルは、<b>自作のメッシュ、自作のシェーダ、自作の影、そして自作の頂点変更</b>など、フレームワークでは一般化しきれない機能を実装するための、ガイドラインです。<br />
　ここの述べた方法を応用すれば、かなり自由な独自の演出を加えることができます。<br />
　また、ここに述べた過程でも説明しましたように、<b>フレームワークの機能は、利用できる部分は利用して、超える部分だけ自作する</b>という手法が、比較的楽にカスタマイズできると思います。この項でも、<b>正8角形の作成</b>を自作していたら、それだけで時間がかかってしまいます。<br />
　また、メッシュの頂点フォーマットも、今回紹介した<b>VertexPositionNormalColor型</b>のほかにも、<b>VertexPositionColorTexture型</b>や<b>VertexPositionNormal型</b>といったフォーマットにも対応可能です。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="40_05.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
