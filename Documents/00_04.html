<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．チュートリアル</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>００４．オブジェクトの衝突判定</h3>
<br />
<h4>XBox360コントローラでの操作CollisionObbコンポーネントによる衝突判定</h4>
　<b>DxBase2015</b>では前項で紹介したような移動するオブジェクトが衝突した場合、それを検知する<b>自動衝突判定</b>機能がついてます。<br />
　<b>Tutorial004ディレクトリ</b>内のソリューション<b>DxBase2015Desktop.sln</b>を<b>VisualStdio2013</b>で開くと以下のような実行画面が出てきて、ボックスが2つ配置されてます。<br />
　<b>XBox360コントローラ</b>を装着するとカメラの操作をすることができます。<b>左十字パッド（Dパッド）</b>の下方を押すとカメラを引きます。上方でカメラが寄ります。<b>右スティックを操作する</b>とカメラ位置が回転します。<br/>
　このカメラは、<b>DxBase2015</b>にあらかじめ内蔵されているカメラで<b>LookAtCamera</b>といいます、主にデバッグ用に利用します。<br />
　残念ながら、<b>Tutorial004サンプル</b>は<b>キーボードやマウス</b>には対応していません。<b>キーボードやマウス</b>への対応方法は、<b>キーボード及びマウス入力のサンプル</b>を確認ください。<br />
　<b>DxBase2015</b>のチュートリアルやサンプルは、ほとんどのケース（キーボードやマウスの説明サンプル以外）では、<b>XBox360コントローラ</b>が必須になります。このことは、<b>各種サンプルを検証するためにも重要</b>なことです。ぜひ、お近くの電気店等でお買い求めください。<br />
　<b>Tutorial004</b>を実行すると以下のよう画面が出てきます。<b>XBox360コントローラ</b>でカメラ操作が可能です。以下の画面は、少しカメラを引いて、カメラ位置を回転させています
<p>&nbsp;</p>
<img src="img/0004a.jpg" width="80%"/>
<p>図0004a</p>
<p>&nbsp;</p>
<h4>Upodate2()仮想関数</h4>
　<b>Character.h、Character.cpp</b>には、前項と同じように、<b>Boxクラス</b>が宣言定義されています。<br />
<br />
<div class="box1">
<pre>
//--------------------------------------------------------------------------------------
//  class Box : public GameObject;
//  用途: ボックス
//--------------------------------------------------------------------------------------
class Box : public GameObject{
    Vector3 m_StartPos;
    float m_Span;
public:
    //構築と破棄
    Box(const shared_ptr&lt;Stage>& StagePtr, const Vector3& StartPos);
    virtual ~Box();
    //初期化
    virtual void Create() override;
    //更新
    virtual void Update() override;
    <span class="red">virtual void Update2() override;</span>
};
</pre>
</div>
<br/>
　上記は、<b>Character.h</b>に記述がある<b>Boxクラスの宣言</b>ですが、あらたに
<div class="box1">
<pre>
    <span class="red">virtual void Update2() override;</span>
</pre>
</div>
　という仮想関数が宣言されています。<br/>
<br />
<h4>Upodate()仮想関数群</h4>
　<b>Update系の仮想関数</b>には、前項で紹介した<b>Upodate()仮想関数</b>そして上記の<b>Upodate2()仮想関数</b>、そしてもう1つ<b>Upodate3()仮想関数</b>があります。<br />
　これらは、あるきまったタイミングでフレームワークから呼び出されます。各ゲームオブジェクトで多重定義しなければ、デフォルトの処理（何もしない）が行われます。<br />
　これはオブジェクト指向の<b>ポリモーフィズム</b>をC++的に具現化したものです<br />
　配置オブジェクトに対する<b>Upodate()仮想関数</b>は、各ターンの冒頭に呼び出されます。各ゲームで定義されたオブジェクト（GameObjectの派生クラス）では、移動したり、回転したり、必要であれば拡大縮小したりします。<br />
　その後、<b>Update系コンポーネント</b>と呼ばれる<b>コンポーネント群</b>の<b>Update()仮想関数</b>が呼ばれます。ここで、今回紹介する<b>衝突判定コンポーネント</b>などの自動処理が行われます。<br />
　その後、配置オブジェクトに対する<b>Upodate2()仮想関数</b>が呼ばれます。ここで、<b>コンポーネントの自動処理</b>に対する検証を行います。<b>今回のテーマはこの関数</b>です。<br />
　その後、<b>コンポーネントの自動事後処理</b>である、<b>コンポーネント群</b>の<b>Update2()仮想関数</b>が呼ばれます。コンポーネントによっては、たとえば、<b>衝突判定コンポーネント</b>などは、<b>衝突後の自動反発</b>などが実装されています（自動反発は次項で解説します）。<br/>
　最後に、配置オブジェクトに対する<b>Upodate3()仮想関数</b>が呼ばれます。各種コンポーネントの自動処理が気に食わなかったり、あるいはゲーム特有の動きに推移する場合など、<b>Upodate3()仮想関数</b>を多重定義することで実装可能です。<br />
<br />
　このように多岐にわたる、<b>Upodate系仮想関数</b>ですが、気になるのは、膨大な量の仮想関数呼びだしが各ターンごとに発生すること、かもしれません。<br />
　確かに100個の配置オブジェクトがあれば、各オブジェクトごとに最低5個以上の呼び出しが入るので、500回以上の仮想関数呼び出しが入ります。<br />
　しかし、ライブラリのソースを見るとわかりますが、<b>Upodate系仮想関数</b>はデフォルト処理（何もしない処理）がインライン化されているため、仮想関数が実装されてなければコンパイラが最適化してくれます。そのため、多重定義された仮想関数があるときのみ、負担が発生します。<br />
　それでも、たとえばC++のVテーブル参照などのオーバーヘッドが気になる人は、<b>void Stage::UpdateStage()仮想関数</b>をGameStageや新規で作成したステージで多重定義してください。<br />
　Update系仮想関数呼び出しは、<b>void Stage::UpdateStage()仮想関数</b>で呼び出しているので、多重定義で不必要な呼び出しをしなければ最適化できます。その場合、コンポーネントの更新なども自動的には呼ばれないので、各自管理してください。<br />
　<b>DxBase2015</b>は全ソースが公開されているので、その辺のメカニズムは調べればわかると思います。<br />
　念のため付け加えておきますが、これまで学生諸君が作成したゲームで、仮想関数呼び出しのオーバーヘッドがゲームに支障をきたしたことはありません。むしろ呼ばれた先の仮想関数の記述を最適化することで、多くの処理時間は削減されます。<br />
<br />
<h4>CollisionObbコンポーネントによる衝突判定</h4>
　このチュートリアルでは、<b>自動衝突判定</b>機能を実装します。具体的には、<b>Character.cpp</b>の<b>void Box;;Create()関数</b>で実装します。<br />
<br />
<div class="box1">
<pre>
//初期化
void Box::Create(){
    auto PtrTransform = GetComponent&lt;Transform>();
    PtrTransform->SetScale(1.0f, 1.0f, 1.0f);
    PtrTransform->SetRotation(0.0f, 0.0f, 0.0f);
    PtrTransform->SetPosition(m_StartPos);
    //OBBの衝突判定をつける
    <span class="red">auto PtrObb = AddComponent&lt;CollisionObb>();</span>
    //影をつける
    auto ShadowPtr = AddComponent&lt;Shadowmap>();
    ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");
    auto PtrDraw = AddComponent&lt;BasicPNTDraw>();
    PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
    PtrDraw->SetTextureResource(L"TRACE_TX");
    //透明有効
    SetAlphaActive(true);
}
</pre>
</div>
　上記、赤くなっているところが<b>衝突判定</b>を実装しているところです。<br />
　<b>衝突判定はコンポーネント</b>として実装し、ここでは<b>CollisionObb</b>という直方体型のボリュームに対する判定を行います。<br />
　<b>DxBase2015</b>では、<b>衝突判定機能</b>を実装するために<b>境界ボリューム</b>を利用しています。<br />
　<b>境界ボリューム</b>というのは、単純化された形状を持つオブジェクトで、<b>球体、カプセル、直方体</b>の3つの<b>境界ボリューム</b>を実装可能です。<br />
　球体ボリュームは<b>CollisionSphere</b>というコンポーネントで、カプセルは<b>CollisionCapsule</b>、そして直方体型は、<b>CollisionObb</b>です。ここでいう<b>OBB</b>は軸に対して自由に回転を掛けられる直方体です。これに対して<b>AABB</b>は軸に対して平行な直方体です。当然<b>AABB</b>の方が単純ですが、<b>AABB</b>の自動衝突判定は持っていません。大は小を兼ねる、ではないですが、基本的に<b>AABB</b>は<b>OBB</b>の特殊形なので要件的には用が足ります。自動衝突判定には<b>AABB</b>は持ってませんが、ライブラリに関数としては存在するので、利用することも可能です。<br />
<br/>
　今回の例では衝突判定に<b>CollisionObb</b>を使っているわけですが、
<div class="box1">
<pre>
    //OBBの衝突判定をつける
    <span class="red">auto PtrObb = AddComponent&lt;CollisionObb>();</span>
</pre>
</div>
　と1行追加すれば、判定をするようになります。しかし、これでは<b>判定</b>をするだけで、事後処理は行いません。<br/>
　事後処理をするためには<b>Update2()仮想関数</b>を使います。以下がそのソースです。
<div class="box1">
<pre>
void Box::Update2(){
    auto CollisionPtr = GetComponent&lt;Collision>();
    if (<span class="red">CollisionPtr->GetHitObject()</span>){
        //もし衝突したら反対方向に移動
        m_Span *= -1.0f;
    }
}
</pre>
</div>
　赤くなっているところがポイントです。<b>CollisionPtr->GetHitObject()</b>は、何かと衝突したら相手のポインタを取得します。衝突してなければnullptrが返ります。<br />
　今回のケースでは、配置されているのが2個で、どちらも同じクラスのインスタンスなので、相手がどのクラスでどのオブジェクトか確認する必要はありません。ですので、ここでは反対方向に反発するように、設定しています。<br />
　もし、Update2()を記述しないとどうなるかというと、衝突したまま2つのオブジェクトが停止します。<br />
　これはどういうことかというと、Update()関数で、Positionnを変更するのですが、変更する前に衝突しているので、衝突判定コンポーネントは衝突点まで位置を戻します。これが毎ターン行われるので、結果、静止してしまいます。
<br/>
　衝突判定でもう一つ特筆すべきは、<b>衝突判定コンポートを持ってるもの同士</b>しか判定しない、ということです。これは、たとえばプレートなどと判定するのを避けるためで、この仕様である程度効率化が図れます。<br />
　また、<b>1回のターンで、それぞれが衝突する相手は1つのみ</b>、という仕様になってます。現実には複数のオブジェクトと同時に衝突することもあるはずですが、それは行ってません。<br />
<br />
<h4>LookAtCameraの設定</h4>
　このサンプルから、カメラは、寄ったり引いたり回転したりできるカメラとなってます。<br />
　これを<b>LookAtCamera</b>といい、デバッグ用に用意されています。カメラを操作するには冒頭述べたように、<b>XBox360コントローラ</b>が必要です。<br />
　<b>LookAtCamera</b>を実装するには<b>GameStage.cpp</b>の<b>void GameStage::CreateViews()関数</b>で行います。
<div class="box1">
<pre>
//ビュー類の作成
void GameStage::CreateViews(){
    //中略
    //最初のビューにパラメータの設定
    PtrView->ResetParamaters&lt;<span class="red">LookAtCamera</span>, MultiLight>(
        rect, 
        Color4(0.0f, 0.125f, 0.3f, 1.0f), 
        1, 
        0.0f, 1.0f
        );
    //中略
}
</pre>
</div>
　のように記述します。<br />
<br />
<h4>インスタンスの複製作成</h4>
　今回は<b>Boxクラスのインスタンスを2個</b>作成しています。記述は<b>GameStage.cpp</b>の<b>void GameStage::CreateBox()関数</b>で行ってます。
<div class="box1">
<pre>
    //ボックスの作成
    void GameStage::CreateBox(){
        AddGameObject&lt;Box>(Vector3(-8.0f, 0.5, 0));
        AddGameObject&lt;Box>(Vector3(0.0f, 0.5, 0));
    }
</pre>
</div>
　で2個配置されます。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_03.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_05.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
