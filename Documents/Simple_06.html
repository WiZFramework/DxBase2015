<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>シンプルDxBase2015</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>Simple06．独自フォーマットのモデルデータの読み込み</h3>
<br />
<h4>Fbx2Binツールで作成したデータを読み込む</h4>
　<b>DxBase2015Simple/Simple06</b>のソリューションを開いて、リビルド、実行しますと以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/Simple06a.jpg" width="80%"/>
<p>図Simple06a</p>
<p>&nbsp;</p>
　このサンプルは、ツール01<b>Fbx2Bin</b>で作成した<b>スタティックメッシュデータ</b>を読み込み、表示するものです。<br />
　FBX_SDKは多機能ではありますが、どうしても大きいため、ミニゲームなどのエンジンには重すぎるという事情があります。（動作速度は充分に速いのですが、サイズ的にという意味です）<br />
　また<b>DxBase2015シンプルバージョン</b>ではFBX_SDKは実装されないので、モデルの描画をする場合は、<b>データを自作</b>しなくてはなりません。<br />
　<b>データを自作</b>と書くと、それだけで引いてしまう人もいるかもしれませんが、そうでもありません。<br/>
　これまで<b>DxBase2015シンプルバージョン</b>では、頂点バッファやインデックスバッファの作成方法を説明してきました。<br />
　正8面体を作成するためには、いったん、頂点とインデックスの配列に正8面体のデータを作成し、それでバッファを作成してきました。<br />
　ようは、この役割を<b>モデルに対して行う処理</b>をすればいいのです。<br />
<br />
<h4>Fbx2Binツールで保存するファイルフォーマットとは</h4>
　<b>Fbx2Binツール</b>では、FBXファイルを読み込んで、そのデータを保存します。今回のサンプルでは、そうして作成したデータを<b>mediaディレクトリ</b>に保存してあります。<br />
　<b>Fbx2Binツール</b>が作成するデータは、大きく分けて<b>ファイルヘッダ、頂点ブロックヘッダ、頂点データ、インデックスブロックヘッダ、インデックスデータ、マテリアル数ヘッダ、（「マテリアル数だけ」マテリアルヘッダ、マテリアル本体）</b>の順に並んでます。<br />
　これらを読み込む関数は<b>GameObject::ReadMesh()</b>にあります。以下はまず、ファイルヘッダの読み込みです。
<div class="box1">
<pre>
    //メッシュデータの読み込み
    void GameObject::ReadMesh(vector&lt;VertexPositionNormalTexture>& vertices, 
        vector&lt;uint16_t>& indices, vector&lt;MaterialEx>& materials){
        auto MeshFileName = App::GetApp()->m_wstrRelativeDataPath 
            + L"Chara_R.bin";
        BinaryReader Reader(MeshFileName);
        <span class="red">//ヘッダの読み込み
        auto pHeader = Reader.ReadArray&lt;char>(16);</span>
        string str = pHeader;
        if (str != "BDV1.0"){
            throw BaseException(
                L"データ形式が違います",
                MeshFileName,
                L"GameObject::ReadMesh()"
                );
        }

        //中略

    }
</pre>
</div>
　<b>BinaryReaderクラス</b>はバイナリファイルの読み取り用のクラスです。DirectXTKからの抜粋です。このクラスは、バイナリデータの中のブロックを指定した型（構造体）で細かく読み込むことができるので便利です。ただ条件があって、<b>POD型</b>でないと指定できません。<b>POD型</b>というのは、<b>コンストラクタやメンバ関数を持たない型</b>とざっくりした意味ですが、要は<b>C言語でも使える型（構造体）</b>ということです。そのため若干のやりくりが必要になります。<br />
　読み込みはまず、<b>ファイルヘッダ</b>を読み込みます。これは、このデータが<b>間違いなくこのアプリケーションで利用する形式か</b>を判別します。<br />
　こういった直接バイナリデータをやり取りする場合は、拡張子はあてになりません。それに、<b>Fbx2Bin</b>で作成するデータはデフォルトで<b>.bin(バイナリという意味)</b>という拡張子になります。この拡張子は、プログラムの拡張子として使われることもあります。ですのでなおさら拡張子はあてになりません。<br />
　<b>Fbx2Binツールが書き出すファイルヘッダ</b>は<b>15バイト以下の文字列</b>です。デフォルトで<b>BDV1.0</b>と入ってます、この文字列を変更することもできます（Fbx2Binツールと合わせます）。ようは、ツールの書き出しと同じ文字列であればよいのです。<br />
　<b>BinaryReaderクラスのReadArray<T>()テンプレート関数</b>は、読みだす方と読み出す数（指定した型のブロック数）を与えます。ここでは<b>char型の16個（16バイト）</b>を指定しています。<br />
　<b>BinaryReaderクラス</b>はシーケンシャル（頭から順番に）にデータを読み出します。ですので、ファイルヘッダを読み込んだ後は、次に並んでいるデータを読みだせます。<br />
<br />
　続いて読み込むのは<b>ブロックヘッダ</b>です。ブロックヘッダとは続いてどんなデータが何バイト入ってるか記述されたデータです。この部分は<b>BlockHeader構造体</b>となっていて、<b>BlockType</b>という<b>enum class</b>を含みます。
<div class="box1">
<pre>
    enum class BlockType{
        Vertex,
        Index,
        Material,
        MaterialCount,
        SkinedVertex,
        BoneCount,
        AnimeMatrix,
        End = 100
    };

    struct BlockHeader{
        BlockType m_Type;
        UINT m_Size;
    };
</pre>
</div>
　<b>enum class</b>というのは<b>enumの強化版</b>で<b>C++11</b>で実装されたものです。通常の<b>enum</b>だと<b>unsigned int</b>と混同されやすいので、できるだけ<b>enum class</b>を使いましょう。<br />
　定義されているブロック型は<b>Vertexなど8種類</b>です。<b>BlockHeader構造体</b>の<b>m_Type</b>はこれらのいずれかになっています。続く<b>m_Size</b>はそのバイト数です。バイナリデータの場合は、1バイト単位まできっちり管理する必要があります。<br />
　読み込みに戻ります。ファイルヘッダ位に続いて、<b>ブロックヘッダ</b>を読み込みますが、ここには必ず<b>頂点ブロック（BlockType::Vertex）</b>が入っているはずです。（<b>Fbx2Binツール</b>がそのように保存しています）。ですので、それ以外であれば、エラーとなります。
<div class="box1">
<pre>
        //頂点の読み込み
        auto blockHeader = Reader.Read&lt;BlockHeader>();
        if (blockHeader.m_Type != BlockType::Vertex){
            throw BaseException(
                L"頂点のヘッダが違います",
                MeshFileName,
                L"GameObject::ReadMesh()"
                );
        }
</pre>
</div>
　ブロックヘッダが問題なければ、続いて頂点データそのものを、ブロックヘッダで指定されたサイズ<b>m_Size</b>ぶんだけ読み込みます。
<div class="box1">
<pre>
        auto VerTexSize 
        = blockHeader.m_Size / sizeof(VertexPositionNormalTexturePOD);

        auto pVertex 
        = Reader.ReadArray&lt;VertexPositionNormalTexturePOD>((size_t)VerTexSize);
</pre>
</div>
　ここで出てきた<b>VertexPositionNormalTexturePOD</b>というのは、<b>VertexPositionNormalTexture</b>を<b>POD化</b>したものです。<b>VertexPositionNormalTexture</b>はコンストラクタを持っているので、<b>PODではありません</b>。<b>VertexPositionNormalTexturePOD</b>は以下のような内容です。
<div class="box1">
<pre>
    struct VertexPositionNormalTexturePOD{
        float position[3];
        float normal[3];
        float textureCoordinate[2];
    };
</pre>
</div>
　この型にデータを読み込んだ後、<b>VertexPositionNormalTexture型</b>の変数に代入し、それを配列に追加しています。<br /
　このようにして、<b>インデックス</b>も読み込みます。<b>インデックス</b>は<b>uint16_t型</b>で、これは<b>POD</b>なのでこのまま利用します。<br />
<br />
　インデックスの後、マテリアルが続いてますが、複数のマテリアルを持ってる可能性があるので、マテリアルのブロックヘッダの前に<b>マテリアルカウントヘッダ（BlockType::MaterialCount）</b>が入ります。これは内蔵する<b>マテリアル数</b>が入ってます（ここだけ、m_Sizeはバイト数ではなくマテリアル数です）。<br />
　なので、この数ぶんだけマテリアルを読み込みます。マテリアルも<b>PODではない</b>のでやりくりが必要です。<br />
　マテリアルには、デフィーズ色やスペキュラー色など、モデルそのものに効果をつける場合の情報が入ってます。（今回のサンプルでは利用してません）。<b>Fbx2Binツール</b>とのやり取りを確認しながら、これらの色を場合によっては使用するとよいでしょう。また、実は<b>Fbx2Binツール</b>も、FBXの持ってるそれらの情報を正確に読みだしているわけではありません。実際に正確さ（つまりモデルの作成現場との整合性）を考えるならば、FBXを作成するときの保存オプションなどとの調整が必要になります。<br />
　つまり、デザイナーが表現したい意図が、FBXのデータとして反映され、それを<b>Fbx2Binツール</b>が読み取り、バイナリデータに書き出せれば、ゲーム側で読み出せることになります。（ややこしいようですが、すべては情報の受け渡し方法の問題です）。<br />
　また、マテリアルには、テクスチャファイル名も含まれますので、そのファイル名を使って、シェーダーリソースビューをマテリアルごとに作成します。<br />
　最後に<b>End</b>というブロックヘッダを読み込みます。これは、データに問題がないかを最終的にチェックするものです。<br />
<br />
<h4>データの表示</h4>
　このようにして読み込んだデータは、内容的には<b>VertexPositionNormalTexture型</b>のデータです。ですので、<b>DxBase2015Simple/Simple04</b>の表示とほぼ同じになります。<br />
　違う点は、マテリアルが複数ある場合があるので、インデックスの描画を複数回行う可能性があるということです。（今回のサンプルの<b>Chara_R.bin</b>はマテリアルは一つしか持っていません）。<br />
　それは以下のように記述しています。<b>GameObject::Draw()関数</b>です。
<div class="box1">
<pre>
    void GameObject::Draw(){

        //中略

        for (auto& m : m_Materials){
            //テクスチャを設定
            pID3D11DeviceContext->PSSetShaderResources(0, 1, m.m_ShaderResView.GetAddressOf());
            //インプットレイアウトの設定
            pID3D11DeviceContext->IASetInputLayout(VSTexture3D::GetPtr()->GetInputLayout());
            //コンスタントバッファの設定
            ID3D11Buffer* pConstantBuffer = CBTexture3D::GetPtr()->GetBuffer();
            pID3D11DeviceContext->VSSetConstantBuffers(0, 1, &pConstantBuffer);
            pID3D11DeviceContext->PSSetConstantBuffers(0, 1, &pConstantBuffer);
            //レンダリングステート
            pID3D11DeviceContext->RSSetState(RenderStatePtr->GetCullFront());
            <span class="red">//描画
            pID3D11DeviceContext->DrawIndexed(m.m_IndexCount, m.m_StartIndex, 0);</span>
            //レンダリングステート
            pID3D11DeviceContext->RSSetState(RenderStatePtr->GetCullBack());
            <span class="red">//描画
            pID3D11DeviceContext->DrawIndexed(m.m_IndexCount, m.m_StartIndex,0);</span>
        }
        //後始末
        Dev->InitializeStates(RenderStatePtr);
    }
</pre>
</div>
　このようにマテリアルの数だけ描画します。注意すべきは赤くなっている部分です。インデックス上の描画範囲を設定しています。<br />
<br/>
<h4>まとめと応用</h4>
　今回は<b>モデルの独自データを使用する</b>例をツール（Fbx2Bin）を使うことで実装する方法を説明しました。この方法を応用すれば、いろんなケースが考えられます。<br />
　<b>DxBase2015</b>に限らず、いろんなミドルウェア（DirectXなどのプリミティブエンジンとアプリケーションの間をつなぐエンジン）は数多くあります。<br />
　それらのミドルウェアはそれぞれいろんな特徴がありますが、不特定多数の要望に応えるため、また初心者にも簡単に扱えるように、巨大化し、多機能化する傾向があります。<br />
　もちろん、実装されていても使わなければ多くな場合問題ありませんが、実際に動かす環境によってはスペックやHDD容量の壁があり、巨大化したミドルウェアがそのまま動かせるとは限りません。また、ミドルウェアが占める容量をできれば、他のことに利用したいと思う場合もあります。<br />
　そんな時は、ミドルウェアの余分な部分を捨てて、できるだけコンパクトにして実装する必要があります。<b>DxBase2015シンプルバージョン</b>がその一例です。<br />
　しかしこのような、スケルトンに近いミドルウェアだと、通常のミドルウェアでは当たり前にできていたことを自作しなければいけないケースが出てきます。今回のケースはまさにこのケースです。<br />
　それを実現する、助っ人的な役割をするのが<b>Fbx2Bin</b>などのデータ変換ツールです。モデル以外でも、たとえば、ステージマップを作成するツールとか、それらのマップを独自フォーマットにした場合の読み書きのツールとか、<b>こんなツールがあったらいいな</b>と思えるものはいくらでもあります。<br />
　また、それらのツールは<b>一般的である必要がない</b>のです。今回の例では、データの並びは<b>頂点、インデックス、マテリアル</b>の順番に並んでいました。これは決め打ち的です。しかし、ブロックヘッダを読みながらケースに分けて、頂点やインデックスを読み出す関数を呼ぶ形にすることもできます。これで少し汎用的になります。しかし、<b>Fbx2Bin</b>が広く一般的に使われているものであればその必要はありますが、<b>DxBase2015サンプル</b>としてローカル的なツールなので、実際にはその必要がありません。<br />
<br />
　つまるところ、ツールの仕様やそのデータの仕様は、<b>勝手に決められる</b>のです。個人、チーム、あるいは、企業や学校の中だけで通用すればいいので、どんな仕様にでもできます。そう考えると、いろんなアイディが出てくると思います。たとえば、前項で説明した頂点に色を付ける場合を、ツールの中に取り込むにはどうしたらいいか、また読み出す側で、どのように読めばいいのか、など、こうでなくてはならない、という決まりはなく、ツールと読み出す側で連絡が取れればいいのです。<br />
　皆さんもぜひ、いろんなツールを試してみてください。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="Simple_05.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="Simple_07.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
