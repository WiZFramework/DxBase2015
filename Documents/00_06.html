<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．チュートリアル</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>００６．アップデート系コンポーネント</h3>
<br />
<h4>プレイヤーと様々なオブジェクト</h4>
　ここでは、プレイヤーをはじめ、プレイヤーに影響を与える様々なオブジェクトを実装します。<br />
　<b>Tutorial006ディレクトリ</b>のソリューションをリビルドし、実行すると以下のような実行画面になります。<br />
　<b>XBox360コントローラ</b>により中央に配置されいている球体を、左スティック移動させることができます。Aボタンでジャンプします。チュートリアル004で説明した<b>LoookAtCamera</b>と組み合わせることによって、自由に向きを変えながら移動させることができます。
<br />
<p>&nbsp;</p>
<img src="img/0006a.jpg" width="80%"/>
<p>図0006a</p>
<p>&nbsp;</p>
<br/>
<h4>プレイヤーの宣言</h4>
　まず一番重要な<b>プレイヤー</b>から見ていきましょう。<br />
　プレイヤーは<b>Player.h、Player.cpp</b>にコードがあります。<br/>
　以下はPlayerクラスの宣言です。<b>Player.h</b>に記述があります。<br />
<div class="box1">
<pre>
//--------------------------------------------------------------------------------------
//  class Player : public GameObject;
//  用途: プレイヤー
//--------------------------------------------------------------------------------------
class Player : public GameObject{
    shared_ptr&lt; StateMachine&lt;Player> >  m_StateMachine;   //ステートマシーン
    //移動の向きを得る
    Vector3 GetAngle();
public:
    //構築と破棄
    Player(const shared_ptr&lt;Stage>& StagePtr);
    virtual ~Player(){}
    //初期化
    virtual void Create() override;
    //アクセサ
    shared_ptr&lt; StateMachine&lt;Player> > GetStateMachine() const{
        return m_StateMachine;
    }
    //ジャンプ開始
    void StartJump();
    //更新
    virtual void Update() override;
    virtual void Update2() override;
    virtual void Update3() override;
};

//--------------------------------------------------------------------------------------
//  class DefaultState : public ObjState&lt;Player>;
//  用途: 通常移動
//--------------------------------------------------------------------------------------
class DefaultState : public ObjState&lt;Player>
{
    //--------------------------------------------------------------------------------------
    //  DefaultState(){}
    //  用途: コンストラクタ
    //  戻り値: なし
    //  ＊シングルトンのため、Instance()関数を介して呼び出す
    //--------------------------------------------------------------------------------------
    DefaultState(){}
public:
    //--------------------------------------------------------------------------------------
    //  static DefaultState* Instance();
    //  用途: インスタンスの取得
    //  戻り値: DefaultStateのインスタンス
    //--------------------------------------------------------------------------------------
    static shared_ptr&lt;DefaultState> Instance();
    //--------------------------------------------------------------------------------------
    //  virtual void Enter(
    //  const shared_ptr&lt;Player>& Obj    //ステートを保持するオブジェクト
    //  ) = 0;
    //  用途: ステートに入ったときに実行される
    //  戻り値: なし（純粋仮想関数）
    //--------------------------------------------------------------------------------------
    virtual void Enter(const shared_ptr&lt;Player>& Obj)override{}
    //--------------------------------------------------------------------------------------
    //  virtual void Execute(
    //  const shared_ptr&lt;Player>& Obj        //ステートを保持するオブジェクト
    //  ) = 0;
    //  用途: Updateのときに実行される
    //  戻り値: なし（純粋仮想関数）
    //--------------------------------------------------------------------------------------
    virtual void Execute(const shared_ptr&lt;Player>& Obj)override;
    //--------------------------------------------------------------------------------------
    //  virtual void Exit(
    //  const shared_ptr&lt;Player>& Obj        //ステートを保持するオブジェクト
    //  ) = 0;
    //  用途: ステートを出るときに実行される
    //  戻り値: なし（純粋仮想関数）
    //--------------------------------------------------------------------------------------
    virtual void Exit(const shared_ptr&lt;Player>& Obj)override{}
};

//--------------------------------------------------------------------------------------
//  class JumpState : public ObjState&lt;Player>;
//  用途: ジャンプ状態
//--------------------------------------------------------------------------------------
class JumpState : public ObjState&lt;Player>
{
    //--------------------------------------------------------------------------------------
    //  JumpState(){}
    //  用途: コンストラクタ
    //  戻り値: なし
    //  ＊シングルトンのため、Instance()関数を介して呼び出す
    //--------------------------------------------------------------------------------------
    JumpState(){}
public:
    //--------------------------------------------------------------------------------------
    //  static shared_ptr&lt;JumpState> Instance();
    //  用途: インスタンスの取得
    //  戻り値: DefaultStateのインスタンス
    //--------------------------------------------------------------------------------------
    static shared_ptr&lt;JumpState> Instance();
    //--------------------------------------------------------------------------------------
    //  virtual void Enter(
    //  const shared_ptr&lt;Player>& Obj    //ステートを保持するオブジェクト
    //  ) = 0;
    //  用途: ステートに入ったときに実行される
    //  戻り値: なし（純粋仮想関数）
    //--------------------------------------------------------------------------------------
    virtual void Enter(const shared_ptr&lt;Player>& Obj)override;
    //--------------------------------------------------------------------------------------
    //  virtual void Execute(
    //  const shared_ptr&lt;Player>& Obj        //ステートを保持するオブジェクト
    //  ) = 0;
    //  用途: Updateのときに実行される
    //  戻り値: なし（純粋仮想関数）
    //--------------------------------------------------------------------------------------
    virtual void Execute(const shared_ptr&lt;Player>& Obj)override;
    //--------------------------------------------------------------------------------------
    //  virtual void Exit(
    //  const shared_ptr&lt;Player>& Obj        //ステートを保持するオブジェクト
    //  ) = 0;
    //  用途: ステートを出るときに実行される
    //  戻り値: なし（純粋仮想関数）
    //--------------------------------------------------------------------------------------
    virtual void Exit(const shared_ptr&lt;Player>& Obj)override{}
};
</pre>
</div>
　一番上に、<b>Playerクラス</b>の宣言がありますが、そのあと、<b>DefaultState、JumpState</b>という変わったクラスがあります。これは、<b>ステート</b>といって、<b>ステートマシン</b>というオブジェクトによって管理される<b>状態</b>をあらわすクラスです。<br />
<br />
<h4>ステート</h4>
　ここで<b>ステート</b>について少し解説します。<br />
　<b>オブジェクト（プレイヤーであれ、敵キャラであれ、ゲーム盤上に配置されるオブジェクト）</b>は、他のオブジェクトとまったくかかわりあわない限り、<b>状態</b>というのを持ってます。<br />
　たとえば、<b>ジャンプしている状態、敵にやられて無敵状態になってる、ダメージを受けて倒れる、剣を持って攻撃する</b>などなどです。<br />
　通常は、このような<b>状態</b>を、<b>Update系の関数</b>で振り分けて、<b>状態</b>に合わせた計算（動き）を実装します。<br />
　前項のプレイヤーのように、状態の振り分けが数種類ならいいのですが、最近ではキャラクターの動きが複雑化しているため、多いときは10種類以上の状態を振り分けなければなりません。<br />
　そのうえ、各<b>状態</b>は、複合的に組み合わさったりします。<br />
　考えを単純にするために、あるオブジェクトの状態が、<b>Ａ、Ｂ、Ｃ、Ｄ</b>の4種類あったとします。<br />
　そして、実装すべき動きが、<b>１、２、３、４、５</b>の種類あったとします。<br />
　<b>Ａの状態のときは１，２</b>を実装します。<b>Ｂの状態のときは１，３、５</b>を実装します。そのようにして、以下のような組み合わせを考えてみましょう。
<div class="box1">
<pre>
Ａ・・・・・１、２
Ｂ・・・・・１、３、５
Ｃ・・・・・２，３
Ｄ・・・・・２、４
</pre>
</div>
　このような実装をする場合、<b>if文やswitch文</b>で振り分けていたのでは、大変なことになります。そのうえ、バグも生みやすい（すべての条件を実装したつもりが、<b>抜け</b>、ができてしまう）こともたびたびあります。<br />
　そんな悩みを一気に解決してくれるのが、<b>ステート</b>です。<br />
　上記の場合、<b>Ａ、Ｂ、Ｃ、Ｄ</b>はそれぞれ<b>ステート</b>になります。そして、<b>１、２、３、４、５</b>は、オブジェクトクラスのメンバ関数などで用意する、ステートから呼び出される前提の関数群です。<br />
　<b>ステート</b>の強さはそれだけではありません。<b>条件によって次のステート</b>移ることも行うのです。<br />
<br />
　<b>ステート</b>は<b>DxBase2015特有の実装ではなく</b>、古くからある有名なアルゴリズムです。各書籍などでも解説されています。<br/>
　<b>DxBase2015</b>はステートを実装しやすいように、2つのクラスがあります。<br />
　<b>ObjState</b>という、各ステートの親クラスに位置する<b>テンプレートクラス</b>と、<b>StateMachine（ステートマシン）</b>という<b>テンプレートクラス</b>です。ステートマシンは派生クラスを作らずに、そのままインスタンスを配置します。<br/>
<br />
　ここに登場する、<b>DefaultStateとJumpState</b>はいずれも、プレイヤーに結び付けられるステートです。ですから、宣言にも<b>Player</b>を指定する箇所があります。<br />
<div class="box1">
<pre>
class DefaultState : public ObjState&lt;Player>
{...
</pre>
</div>
　こんな感じです。<br />
　そして<b>ステートのコンストラクタ</b>はかならず<b>privateメンバ</b>にします。<br />
　クラス宣言は、何もアクセス指定しなければデフォルトで<b>privateメンバ</b>になります。<br />
　これは、<b>ステートはシングルトンとして作成する</b>からです。<b>シングルトン</b>というのは<b>このアプリケーション中、ただ一つしかインスタンスが存在しないクラス</b>です。<br/>
　たとえば、あるゲームオブジェクトクラスが5個のステートを持っていたとします。そしてゲーム画面に100個のインスタンスが配置されたとすると、ステートだけで500個のインスタンスができることになります。<br />
　メモリ効率的にも望ましくありません。ですから<b>同じクラスのすべてのインスタンス</b>が<b>同じステートのインスタンス</b>にアクセスする必要があります。<br />
　そのため、<b>ステートにはメンバ変数は起きません</b>。
<br/>
　コンストラクタが<b>privateメンバ</b>ということは、外部からは構築不可能になるので、何らかの形でシングルトンのインスタンスを取得しなければなりません。それが
<div class="box1">
<pre>
    static shared_ptr&lt;DefaultState> Instance();
</pre>
</div>
　です。このstatic関数で、シングルトンのポインタを取得します。<br />
<br/>
　また、<b>ステートは以下の3つの仮想関数</b>を必ず持ちます。
<div class="box1">
<pre>
    virtual void Enter(const shared_ptr&lt;Player>& Obj)override{}
    virtual void Execute(const shared_ptr&lt;Player>& Obj)override;
    virtual void Exit(const shared_ptr&lt;Player>& Obj)override{}
</pre>
</div>
　これはコメントにあるように、<br />
<div class="box1">
<pre>
そのステートに入ったとき（Enter()関数）
そのステートで実行中（Execute()関数）
そのステートから抜けるとき（Exit()関数）
</pre>
</div>
　に呼ばれます。<br/>
<br />
　また、プレイヤーには、
<div class="box1">
<pre>
    shared_ptr&lt; StateMachine&lt;Player> >  m_StateMachine;   //ステートマシーン
</pre>
</div>
　というメンバがあります。これが<b>ステートマシン</b>です。ステートのマネージャ的な存在です。<br />
　ステートを使う場合は、かならずメンバに保持しておきます。テンプレートクラスなので、保持するクラスを記述しなければなりません。<br />
<br />
<h4>プレイヤーの実体</h4>
　プレイヤーの実体は<b>Player.cpp</b>にコードがあります。<br/>
　まず、ステートから見ていきましょう、以下は、通常状態のステート<b>DefaultState</b>の実体です。
<div class="box1">
<pre>
shared_ptr&lt;DefaultState> DefaultState::Instance(){
    static shared_ptr&lt;DefaultState> instance;
    if (!instance){
        instance = shared_ptr&lt;DefaultState>(new DefaultState);
    }
    return instance;
}
void DefaultState::Execute(const shared_ptr&lt;Player>& Obj){
    //コントローラの取得
    //コントローラはApp内なのでステートから呼んでも問題ない。
    //
    //ただし、ステートクラスにはメンバ変数は設けないこと！（シングルトンのため）
    auto CntlVec = App::GetApp()->GetInputDevice().GetControlerVec();
    if (CntlVec[0].bConnected){
        //Aボタンが押された瞬間ならステート変更
        if (CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_A){
            Obj->GetStateMachine()->ChangeState(JumpState::Instance());
        }
    }
}
</pre>
</div>
　<b>Enter()関数とExit()関数</b>は、宣言部を見ればわかるように、実体が空関数として実装されているので、ここでは、<b>Instance()関数とExecute()関数</b>のみ記述します。
　まず、<b>Instance()関数</b>では、シングルトンを実装するための記述があります。
<div class="box1">
<pre>
    static shared_ptr&lt;DefaultState> instance;
</pre>
</div>
　というのがシングルトンのポインタです。static変数なので、最初に呼ばれたときだけnewで初期化されます。<br />
<br/>
　<b>Execute関数</b>は、Aボタンが押されたときにステートを変更します。Obj（Playerのインスタンス）からステートマシンを取得して、<b>ChangeState()関数</b>でジャンプステートに移行します。この時、<b>JumpState::Instance()</b>と記述することにより、ジャンプステートのポインタを取得します。<br />
<br/>
　プレイヤークラスの実体で注意したいのは、Create()関数内での
<div class="box1">
<pre>
    //ステートマシンの構築
    m_StateMachine = make_shared&lt; StateMachine&lt;Player> >(GetThis&lt;Player>());
    //最初のステートをDefaultStateに設定
    m_StateMachine->SetCurrentState(DefaultState::Instance());
    //DefaultStateの初期化実行を行う
    m_StateMachine->GetCurrentState()->Enter(GetThis&lt;Player>());
</pre>
</div>
　という部分です。ここでステートマシンを構築し、最初のステートを設定します。<br />
<br />
　ステートマシンは、ゲームオブジェクトのUpdate系の関数内で、更新します。<br />
　プレイヤーは<b>void Player::Update()</b>で行ってます。
<div class="box1">
<pre>
    //ステートマシンのUpdateを行う
    //この中でステートの切り替えが行われる
    m_StateMachine->Update();
</pre>
</div>
　という感じです。ステートマシンでは<b>現在のステートのExcute()関数</b>を呼び出し、もしステートの変更がされたら、<b>これまでのステートのExit()</b>を呼び出し、<b>新しいステートのEnter()</b>を呼び出します。<br/>
　このようにゲーム中、ステートの変更を繰り返しながら、進めていきます。<br/>
<br/>
　<b>void Player::Update()</b>の残りの部分では、ステート毎にかわらない共通の処理を行ってます。<br />
　ここでは、プレイヤーをコントローラに合わせて移動させているわけですが、その際、<b>ステアリング</b>というコンポーネントを使用しています。<br />
　<b>ステアリング</b>は日本語では<b>操舵</b>と訳されるかもしれません。主にAI動作に使用される手法で、前項で述べた<b>Rigidbody</b>が<b>速度（Velocity）</b>を自動的に設定します。<br />
　<b>速度（Velocity）</b>は<b>加速</b>を加えることで増減します。動いているのが止まるのも、実は後ろ向きの加速が加わっています。ですから、<b>加速</b>を動的に変えることができれば<b>速度（Velocity）</b>を動的に変更できます。<br />
<br />
　では加速を変化させるのにはどうしたらいいかというと、まず、いわゆる<b>力（フォース）</b>を作り出します。たとえば何かを追いかけるとすれば、<b>追いかけようとするフォース</b>がありますし、目的地に到着するとすれば<b>到着しようとするフォース（ブレーキのようなもの）</b>が発生します。あるルートパスがあってそれに沿って進むとすれば、<b>その道筋に沿うようなフォース</b>が発生します。<b>複数のオブジェクトがお互いに引き合うフォース</b>もありますし、<b>お互いに離れようとするフォース</b>があります。<br />
　これらの一つ一つのフォースを作り出す仕組みが<b>ステアリング（操舵）</b>ということになります。<br/>
　そして、それらのフォースを加算していって、<b>最終的にその物体に影響するフォース</b>を作り出します。<br />
<br />
　全体的なフォースを求めましたら、物質によって質量が違いますので、質量を加味して加速に変換します。重いものに加速を加えるのには多くの力が必要ですし、軽いものであれば少なく済みます。それを計算するのです。<br />
　そして各物質に対する、一瞬一瞬の加速が出せましたら、その加速を使って、<b>現在の速度（Velocity）</b>を変化させます。<br />
<br />
　さて、プレイヤーの場合具体的にはどのような<b>フォース</b>を発生させて、加速を計算してるのかというと、<b>Seek</b>という<b>ステアリング（操舵）</b>を使って<b>フォース</b>を発生させ、<b>Rigidbody</b>を使って加速を計算します。<br />
<br />
　プレイヤーとコントローラの関係は以下のような関係になります。
<p>&nbsp;</p>
<img src="img/0006b.jpg" width="60%"/>
<p>図0006b</p>
<p>&nbsp;</p>
　赤い線が<b>プレイヤーの目的の方向</b>です。<br />
　プレイヤーが現在移動してないのであれば、のであればこのまま赤い方向に向かうフォースを作り出せばいいのですが、<b>現在の速度</b>を加味する場合、そう単純にはいきません。<br />
　<b>フォース</b>の向きは、以下のようになります。
<p>&nbsp;</p>
<img src="img/0006c.jpg" width="60%"/>
<p>図0006c</p>
<p>&nbsp;</p>
　つまり、<b>目的地へのベクトルから現在の速度を引いたベクトル</b>が、求めるべき<b>フォース</b>となります。<br/>
　カメラと自分の向きから、向いたいベクトルは算出できますので、そこに向かうフォースは<b>Seek</b>という<b>ステアリング（操舵）</b>を使って算出します。<br />
　<b>Seekステアリング（操舵）</b>は、コンポーネントとして実装します。<br/>
　コンポーネントの実装は、前項のように<b>Player::Create()</b>に記述します。<br />
　ここでは、<b>Rigidbody、SeekSteering</b>のほかに重力を加味するので、<b>Gravityコンポーネント</b>も追加しています。
<div class="box1">
<pre>
//初期化
void Player::Create(){
    //中略

    //操舵系のコンポーネントをつける場合はRigidbodyをつける
    auto PtrRedit = AddComponent&lt;Rigidbody>();
    <span class="red">//Seek操舵
    AddComponent&lt;SeekSteering>();</span>
    //重力をつける
    auto PtrGravity = AddComponent&lt;Gravity>();
    //最下地点
    PtrGravity->SetBaseY(0.125f);
    //衝突判定をつける
    auto PtrCol = AddComponent&lt;CollisionSphere>();

    //中略

}
</pre>
</div>
<br />
　<b>SeekSteering</b>のパラメータは<b>目標地点（ターゲット）</b>を渡します。そうすると<b>Seekステアリング（操舵）</b>は内部でフォースを作り出し、<b>Rigidbody</b>に渡します。<b>Rigidbody</b>はそこから、加速を作りだします。<br />
<br />
　プレイヤーは常に動き続けているので、<b>目標地点（ターゲット）</b>は常に変化します。それで、コントローラの向きから目標地点を、まるで<b>馬の前にニンジンをぶら下げるように</b>、<b>毎ターンごと</b>に設定します。<br/>
　以下がその部分のコードです。<br />
<br />
<div class="box1">
<pre>
//更新
void Player::Update(){
    //中略

    Vector3 Angle = GetAngle();
    //Transform
    auto PtrTransform = GetComponent&lt;Transform>();

    //現在位置を取り出す
    auto Pos = PtrTransform->GetPosition();
    //移動方向を加算。
    //移動方向だけがわかればいいので、
    //Angleは正規化されてて良い
    Pos += Angle;
    <span class="red">//Seek操舵
    auto PtrSeek = GetComponent&lt;SeekSteering>();
    //加算された方向に追いかける
    PtrSeek->SetTargetPosition(Pos);</span>

    //中略

}
</pre>
</div>
　長々解説してきましたが、実装はいたって単純です。<br />
　<b>Player::Update()関数</b>では、残りの部分は<b>回転を設定</b>します。移動方向とは違って、回転は<b>Transform</b>を直接変更しても大きな問題はありません。<br />
<br />
　プレイヤーはジャンプができます。ジャンプして固定のボックスの上に乗ることができます。動的にプレイヤーのパラメータがどのように変化するかわかるように、パラメータを文字列で表示しています。動かすことで変化する値を確認ください。<br />
<br />
<h4>そのほかのオブジェクト</h4>
　チュートリアル006にはプレイヤーのほかに、プレイヤーを追いかけるオブジェクトが4つ配置されています。<br />
　このソースは<b>Character.h、Character.cpp</b>に記述されています。プレイヤーと同じように<b>ステアリング、そして、Rigidbodyコンポーネント</b>が実装されています。プレイヤーとの違いを確認ください。<br />
<br />
　<b>DxBase2015</b>には<b>ステアリング</b>はこのサンプルで紹介したほかにも、いくつか用意されています。自作することも可能です。それらの紹介は、のちのサンプルで行います。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_05.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
