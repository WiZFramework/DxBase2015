<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３１２．ステージ操作</h3>
<br />
<h4>複数のステージの必要性</h4>
　ゲームは、たとえば<b>メニュー、リザルト画面、クリア画面、ゲームオーバー画面</b>など、複数のステージで構成されています。<br />
　このようなインターフェイスを用意することで、ユーザーに、ゲームの結果を報告したり、あるいは次に行うべきことを提示したりできます。<br />
　同じゲームでもそのあたりのインターフェイスが充実しているのとないのでは、ユーザーの満足度も違います。<br />
　<b>Sample312</b>は<b>ステージ操作</b>です。実は<b>Sample307のSpriteStdioを使ったメニュー</b>でも<b>ステージ操作</b>は実装されていますが、このサンプルでは、抜き出して説明します。<br />
　<b>Sample312</b>のソリューションを開き、リビルド、実行すると以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/3012a.jpg" width="80%"/>
<p>図3012a</p>
<p>&nbsp;</p>
　この画面にあるように、コントローラのBボタンを押すと以下の画面になります。チュートリアル008と同じものです。
<p>&nbsp;</p>
<img src="img/3012b.jpg" width="80%"/>
<p>図3012b</p>
<p>&nbsp;</p>
　ここでBボタンを押すと、最初の画面に戻ります。<br />
　単純な例ですが、これが<b>ステージ操作</b>です。<br />
<br />
<h4>メニューステージの作成</h4>
　まず<b>メニューステージ</b>を作成します。ここでは<b>GameStage.cpp</b>に記述してあります。<br />
　実際にチーム制作などでステージを構成する場合は、別ファイルにして、たとえば<b>MenuStage.hと>MenuStage.cpp</b>を記述する（この場合、新しいヘッダをProject.hに追記を忘れないようにする）方がいいでしょう。<br />
　以下は、ビューを作成しているところです。
<div class="box1">
<pre>
    void MenuStage::CreateViews(){
        //最初にデフォルトのレンダリングターゲット類を作成する
        CreateDefaultRenderTargets();
        //マルチビューコンポーネントの取得
        auto PtrMultiView = GetComponent&lt;MultiView>();
        //マルチビューにビューの追加
        auto PtrView = PtrMultiView->AddView();
        //ビューの矩形を設定（ゲームサイズ全体）
        Rect2D&lt;float> rect(0, 0, (float)App::GetApp()->GetGameWidth(), (float)App::GetApp()->GetGameHeight());
        //最初のビューにパラメータの設定
        PtrView->ResetParamaters&lt;LookAtCamera, MultiLight>(rect, Color4(0.0f, 0.125f, 0.3f, 1.0f), 1, 0.0f, 1.0f);

        //0番目のビューのカメラを得る
        auto PtrCamera = GetCamera(0);
        PtrCamera->SetEye(Vector3(0.0f, 0.0f, -5.0f));
        PtrCamera->SetAt(Vector3(0.0f, 0.0f, 0.0f));
    }
</pre>
</div>
　ここでは、カメラを設定していますが、スプライトだけなので（文字列はスプライトです）、カメラはどこを向いていても構いません。ただ。今後、３Ｄの何らかのオブジェクトを実装した場合、カメラがその方向を向いてないと表示されないので、一応、SetEye()とSetAt()を記述しておきます。<br />
　文字列は、以下のように、<b>MenuStage</b>に直接コンポーネント実装します。
<div class="box1">
<pre>
    void MenuStage::CreateString(){
        //文字列をつける
        auto PtrString = AddComponent&lt;StringSprite>();
        PtrString->SetText(L"Bボタンでゲームを開始します");
        Rect2D&lt;float> rect(0, 0, 200, 200);
        rect += Point2D&lt;float>(200,200);
        PtrString->SetTextRect(rect);
    }
</pre>
</div>
<br />
<h4>シーンでの操作</h4>
　メニューステージができたところで、<b>最初にメニューステージを表示する</b>ように記述しなければなりません。そのためには<b>Scene.cpp</b>に記述します。<br />
　<b>DxBase2015</b>では、1つのゲームに対して、<b>1つのアプリケーション（Appクラス）、1つのシーン（Sceneクラス）と、複数のステージ（GameStageやMenuStage）</b>で構成されます。<br/>
　ステージを管理するのは<b>Sceneクラス</b>です（Scene.h、cpp）。<br />
　その<b>Create()関数</b>に以下のように記述します。
<div class="box1">
<pre>
    void Scene::Create(){
        try{
            //最初のアクティブステージの設定
            ResetActiveStage&lt;<span class="red">MenuStage</span>>();
        }
        catch (...){
            throw;
        }
    }
</pre>
</div>
　こうしておくと、起動直後に<b>MenuStage</b>がまず実装されます。<br/>
<br />
<h4>ステージの切り替え</h4>
　このように、<b>ステージ操作</b>はシーンで行うわけですが、どのタイミングでステージが終了して切り替わるかはゲームによります。<br />
　そのため、ステージを切り替えるためには、シーンに対して<b>イベント</b>を送るようにします。イベントについては<b>サンプル106</b>に説明があります。
　ここでは、まずイベントを受け取る側（つまりシーン）が何を行うかを実装します。以下がシーンの<b>OnEvent()関数</b>です。<br />
<div class="box1">
<pre>
    void Scene::OnEvent(const shared_ptr&lt;Event>& event)
    {
        if (event->m_MsgStr == L"ToGame"){
            ResetActiveStage&lt;GameStage>();
        }

        if (event->m_MsgStr == L"ToMenu"){
            ResetActiveStage&lt;MenuStage>();
        }
    }
</pre>
</div>
　これは実体なので、記述の前にヘッダファイル（Scene.h）で、<b>OnEvent()の多重定義宣言</b>を記述しなければなりませんのでお忘れなく。<br />
　ここでは、イベントの内容によって、メニューを起動するか、ゲームステージを起動するかを振り分けています。<br />
<br />
<h4>イベントの送出</h4>
　では<b>ステージ切り替えのイベント</b>はどのように発行してるのでしょうか？<br />
　メニューステージ側では、ステージの<b>Update()関数</b>で行ってます。
<div class="box1">
<pre>
    void MenuStage::Update(){
        //コントローラ情報の取得.
        auto CntlVec = App::GetApp()->GetInputDevice().GetControlerVec();
        //Bボタンが押されたら.
        if (CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_B) {
            //イベント送出
            <span class="red">PostEvent(0.0f, GetThis&lt;MenuStage>(), App::GetApp()->GetSceneBase(), L"ToGame");</span>
        }
    }
</pre>
</div>
　ここでは、必ず<b>PostEvent()関数</b>を使います。ステージ切り替えは慎重に行われなければなりません。<b>SendEvent()関数</b>で行うと、シーンが終了すべきステージから新しいステージに切り替えるときは、まだ、終了すべきステージのオブジェクトが生きています（というより終了すべきステージの中の関数から呼ばれるので、リターンしたときにオブジェクトが存在しなくなってしまいます）。<br />
　それに対して<b>PostEvent()関数</b>は、次のターンまで処理を待ちますので、ターンの冒頭で（ステージに制御が渡る前）に、終了ステージを破棄しますので、問題なく推移します。<br />
<br/>
　ゲームステージ側のイベント送出は<b>プレイヤーのUpdate3()関数</b>で行ってます。PostEvent()を送るので、どのオブジェクトから送っても問題はありません。<br />
<br />
<h4>ステージ切り替えの内部の動き</h4>
　先ほど、<b>どのオブジェクトから送っても問題はありません</b>と書きましたが、これは、<b>ヌルポインタアクセスなどの致命的なことにはならない</b>ということであり、設計によっては、<b>無駄なステージ切り替え</b>が起こる可能性がるので、内部の（ライブラリ内の）動きを説明しながら、考えられる問題点について述べます。<br />
　多くのゲームの場合、たとえば<b>時間切れになるか、敵に当たるとゲームオーバー</b>のような処理になります。これをどのように実装するかですが、たとえばゲームステージ内のいくつものオブジェクトから、シーンに対して<b>ゲームオーバーに移行しなさい</b>というイベントが発行されるとします。<br />
　これが、違うターンで発行されるのであれば、最初のイベントで、ステージは切り替わりますので、<b>早い者勝ち</b>的な処理になります。<br />
　しかしたまたま、同じターン内で、二つ以上のイベントが送られたら、それらの実行は次のターンの冒頭なので、2回、ステージ切り替えが起こることになります。<br />
　シーンでは、アクティブなステージのポインタ（スマートポインタshared_ptr）を1つ保持しています。<br />
　新しいステージの読み込みは、最初にステージを構築した後、アクティブなスマートポインタを上書きします。その時に、スマートポインタの仕様により、もとのステージは破棄されます。それで、もう一回、同じステージに移行しなさいとイベントが来た場合、構築したばかりのステージを破棄して、また、新しいステージを構築する形になります。つまり1回無駄にステージを構築することになります。<br />
　しかし、2つのイベントが同じステージに移行するイベントであればまだ、見た目はあまり変わらない（実行時間は変わるが）、気が付かないで終わるかもしれませんが、別のステージに移行せよというイベントが、同じターンで複数発行された場合、話はややこしくなります。<br />
　つまり、クリアしたはずなのにゲームオーバーになってしまった、のような現象が出てくる可能性があります。<br />
　60秒分の1の話なので、それも、同じターンで2つ以上イベントが来た場合のことですが、結構あなどってはいけません。<br />
<br />
　そんな場合は、シーン側で、1ターンに1個しかステージ切り替えのイベントに対応しないように記述します。具体的には、たとえばフラグを使うとか、メンバ変数でイベントの数を数えるとか。いろいろ方法はあると思いますが、このような処理は、なかなか見えてこないので、プログラマがある程度現象を予想して、記述しましょう。（サンプルには、そういった処理の記述はありません）<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="30_11.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="30_13.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
