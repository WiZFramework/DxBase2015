<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>シンプルDxBase2015</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>Simple01．線を描画する</h3>
<br />
<h4>デバイス座標に直接描画する</h4>
　このサンプルは、<b>サンプル401</b>に紹介した、<b>デバイス座標への直接描画</b>のシェーダを使用した例です。<br />
　このサンプルでは、行列変換は全く行わずに、<b>頂点の変更</b>で動きを表現します。<br />
　サンプルの<b>DxBase2015Simple/Simple01</b>のソリューションを開いて、リビルド、実行しますと以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/Simple01a.jpg" width="80%"/>
<p>図Simple01a</p>
<p>&nbsp;</p>
　ここでは複数の線が、スクリーンセーバーのように動きます。<br />
<br />
<h4>コード解説</h4>
　<b>シンプルDxBase2015</b>には<b>シーン</b>という考え方はありません。いきなり<b>ステージ</b>になります。<br/>
　また<b>これまでのGameObject</b>も存在しません。<b>GameObject</b>に代わるものとして、サンプルでは<b>ObjectとSimpleInterface</b>の派生クラスとしてb>GameObjectクラス</b>を作成しています。<br />
<br />
　別にこれは、決まりではありません、<b>ステージ</b>は、<b>StageBaseの派生クラス</b>として作成しますが、この派生クラスは、フレームワークから<b>PreCreate()、Create()、Update()、Draw()</b>の4つの仮想関数が呼び出されます。ですので、それに呼応するようにコードを記述すればいいのです。各オブジェクトを配列化などは、サンプルではしてますが、必須ではありません。<br/>
<br/>
　サンプルでの主なコードは<b>GameObjects.h、cpp</b>に記述します。<br />
　以下は、<b>GameObjects.h</b>の<b>GameStageクラス</b>です。<br />
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class GameStage : public StageBase;
    //  用途: ゲームステージ
    //--------------------------------------------------------------------------------------
    class GameStage : public StageBase{
        vector&lt;shared_ptr&lt;GameObject>> m_GameObjectVec;
        shared_ptr&lt;View> m_View;
        shared_ptr&lt;DefaultRenderTarget> m_DefaultRenderTarget;   //デフォルトのレンダリングターゲット
        //文字列
        shared_ptr&lt;StringSprite> m_StringSprite;
    public:
        GameStage(){}
        virtual ~GameStage(){}
        virtual void Create()override;
        virtual void Update()override;
        virtual void Draw()override;
    };
</pre>
</div>
　ここでは、1つしかオブジェクトは用意しませんが、
<div class="box1">
<pre>
        vector&lt;shared_ptr&lt;GameObject>> m_GameObjectVec;
</pre>
</div>
　のように、オブジェクトの配列を用意してます。このほかにビューとレンダリングターゲット、そしてFPS表示用の文字列も用意します。<br />
　コードが前後しますが、以下が<b>GameObjectクラス</b>です。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class GameObject : public Object, public SimpleInterface;
    //  用途: ゲームステージ
    //--------------------------------------------------------------------------------------
    class GameObject : <span class="red">public Object, public SimpleInterface</span>{
        //頂点バッファ
        ComPtr&lt;ID3D11Buffer> m_VertexBuffer;
        //頂点の数
        UINT m_NumVertices;
        //メッシュの作成
        void CreateCustomMesh();
        //頂点の変更
        void UpdateCustomMesh();
        //経過時間
        float m_TotalTime;
    public:
        GameObject() :
            m_TotalTime(0)
        {}
        virtual ~GameObject(){}
        virtual void Create()override;
        virtual void Update()override;
        virtual void Draw()override;
    };
</pre>
</div>
　冒頭赤くなってるとことは、<b>多重継承</b>を行っているところです。
<div class="box1">
<pre>
    class GameObject : <span class="red">public Object, public SimpleInterface</span>{
        //中略
    };
</pre>
</div>
　<b>SimpleInterface</b>は<b>抽象クラス</b>になっていて、<b>Update()、Draw()</b>が純粋仮想関数として宣言されています。なので派生クラスはこれらの関数を多重定義しなければなりません。<br/>
　<b>PreCreate()、Create()</b>は<b>Objectクラス</b>が持っている仮想関数です。<b>Create()</b>のみ純粋仮想関数になっています。ここでは<b>PreCreate()</b>は多重定義しません。<br />
<br/>
<h4>シェーダークラス</h4>
　シェーダーは、<b>VSSimpleDirect.hlsl（頂点シェーダ）とPSSimpleDirect.hlsl（ピクセルシェーダ）</b>を利用します。もともと<b>DxBase2015のライブラリ</b>にあるシェーダです。これらのシェーダを、<b>使いまわしできる形（つまりシングルトン）</b>としてクラス化します。<br />
　これらのクラス化については<b>４０５．頂点を自作する２</b>ドキュメントを参考にしてください。<br />
<br />
　各シェーダを<b>VisualStdio2013</b>のプロジェクトに登録する場合、注意点があります。<br/>
　<b>シェーダファイル</b>のフィルタに右ボタンクリックで「追加」「既存の項目」で追加するわけですが、その際、以下のように各シェーダのプロパティ（HLSLコンパイラ）を設定します。
<p>&nbsp;</p>
<img src="img/Simple01b.jpg" width="80%"/>
<p>図Simple01b</p>
<p>&nbsp;</p>
　この中で注意するのは<b>全般</b>にある<b>シェーダの種類、シェーダーモデル（上図）</b>と<b>出力ファイルのオブジェクトファイル名（下図）</b>です。
<p>&nbsp;</p>
<img src="img/Simple01c.jpg" width="80%"/>
<p>図Simple01c</p>
<p>&nbsp;</p>
　これらの設定を確認しましょう。特に<b>シェーダの種類</b>は各自設定する必要があります。<b>シェーダーモデルと出力ファイルのオブジェクトファイル名</b>は、プロジェクトに追加時に、自動設定されます。<br/>
<br/>
<h4>cppファイル</h4>
　<b>シェーダとシェーダクラス</b>を実装したら、cppファイルの記述をします。<br />
　以下は、<b>GameObject::reateCustomMesh()</b>です。ここで、頂点を作成します。
<div class="box1">
<pre>
    //メッシュの作成
    void GameObject::CreateCustomMesh(){
        vector&lt;VertexPosition> VirtexVec;
        float Span = 2.0f / 100.0f;
        for (size_t i = 0; i &lt; 100; i++){
            float f = -2.0f + cos(0.0f) + (float)i * Span;
            float f2 = -2.0f + sin(0.0f) + (float)i * Span;

            VirtexVec.push_back(Vector3(f, -f2, 0.0f));
            VirtexVec.push_back(Vector3(f2, f, 0.0f));
        }
        //頂点バッファの作成（頂点を変更できる）
        VertexUtil::CreateDynamicVertexBuffer(m_VertexBuffer, VirtexVec);
        //頂点数の設定
        m_NumVertices = static_cast&lt;UINT>(VirtexVec.size());
    }
</pre>
</div>
　このように<b>VertexPosition型</b>の頂点の配列を作成します。この型は、位置情報しか持ってません。線は、開始点と終了点を設定しますので、2個づつ追加します。100本の線（つまり200個の頂点）の配列を作成します。配列を作成したら、
<div class="box1">
<pre>
        //頂点バッファの作成（頂点を変更できる）
        VertexUtil::CreateDynamicVertexBuffer(m_VertexBuffer, VirtexVec);
</pre>
</div>
　で頂点バッファを作成します。<br />
　頂点の変更は<b>GameObject::UpdateCustomMesh()</b>で行います。ここでは、頂点バッファをマッピングして、トータル時間に合わせ、sinもしくはcosで変化させます。<br />
<br/>
　最後に<b>Draw()</b>です。以下がCraw()の実体です。
<div class="box1">
<pre>
    void GameObject::Draw(){
        auto Dev = App::GetApp()->GetDeviceResources();
        auto pD3D11DeviceContext = Dev->GetD3DDeviceContext();
        //ステータスのポインタ
        auto RenderStatePtr = Dev->GetRenderState();
        //コンスタントバッファの準備
        SimpleDirectConstantBuffer sb;
        //線の色は黄色
        sb.m_DiffuseColor = Color4(1.0f, 1.0f, 0, 1.0f);
        //コンスタントバッファの更新
        pD3D11DeviceContext->UpdateSubresource(
            CBSimpleDirect::GetPtr()->GetBuffer(), 0, nullptr, &sb, 0, 0);
        <span class="red">//描画方法（線）
        pD3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);</span>
        //デプスステンシルは使用しない
        pD3D11DeviceContext->OMSetDepthStencilState(RenderStatePtr->GetDepthNone(), 0);
        //コンスタントバッファの設定(ピクセルシェーダのみでよい)
        ID3D11Buffer* pConstantBuffer = CBSimpleDirect::GetPtr()->GetBuffer();
        pD3D11DeviceContext->PSSetConstantBuffers(0, 1, &pConstantBuffer);
        //シェーダの設定
        pD3D11DeviceContext->VSSetShader(VSSimpleDirect::GetPtr()->GetShader(), nullptr, 0);
        pD3D11DeviceContext->PSSetShader(PSSimpleDirect::GetPtr()->GetShader(), nullptr, 0);
        //インプットレイアウトの設定
        pD3D11DeviceContext->IASetInputLayout(VSSimpleDirect::GetPtr()->GetInputLayout());
        //描画
        //ストライドとオフセット
        UINT stride = sizeof(VertexPosition);
        UINT offset = 0;
        pD3D11DeviceContext->IASetVertexBuffers(
            0, 1, m_VertexBuffer.GetAddressOf(), &stride, &offset);
        pD3D11DeviceContext->Draw(m_NumVertices, 0);
        //後始末
        Dev->InitializeStates(RenderStatePtr);
    }
</pre>
</div>
　赤くなっているところが、線描画を設定しているところです。<br/>
<br />
　このように、<b>シンプルDxBase2015</b>はほとんど自動処理はされませんが、一つ一つオブジェクト指向に乗っ取って記述することで、自由度の高いコードを記述すことが可能となっています。<br/>
　ここでは頂点は単純ですが、プリミティブの頂点の作成、テクスチャの設定などは順次紹介します。<br />
　<b>シンプルDxBase2015</b>には、<b>モデルのロード（FBXなど）</b>は用意されてないので、自作することになります。その簡単な方法についても順次説明します

<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="Simple_00.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="Simple_02.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
