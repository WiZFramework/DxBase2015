<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３０６．SpriteStdio5データの再生と操作</h3>
<h4>SpriteStdio5データとは</h4>
　<b>SpriteStdio5データ</b>とは、<b>株式会社ウェブテクノロジ社様</b>が開発した、スプライトアニメーションデータ形式を言います。基本的に<b>XML形式とシンプルな画像データ</b>で保存され、自由自在にスプライトアニメーションを実装できます。<br />
　そのデータを作成するツールが<b>OPTPiX SpriteStudio</b>ということになります。<br />
　<a href="http://www.webtech.co.jp/" target="_blank">ウェブテクノロジ社サイト</a><br />
　<a href="http://www.webtech.co.jp/spritestudio/" target="_blank">OPTPiX SpriteStudioサイト</a><br />
　<b>ウェブテクノロジ社</b>では、この<b>SDK</b>を公開しています。上記<b>OPTPiX SpriteStudioサイト</b>にはいろいろな支援ツールやプレイヤーなどをダウンロードできるようになってますので、そこからSDKをダウンロードしますと、データ形式の詳細を調べることができます。<br />
　また、<b>DxBase2015フレームワーク</b>が、<b>ウェブテクノロジ社</b>の<b>SpriteStudio 3rdParty</b>で、ご紹介いただいてます。<br />
　<a href="http://spritestudio3rdparty.github.io/" target="_blank">SpriteStudio 3rdParty</a><br />


<br />
<h4>SpriteStdio5データを読み込む</h4>
　まず、最初に、サンプル306を起動してみましょう。<br />
　<b>Sample306ディレクトリ内</b>のソリューションを開き、<b>リビルド、そして、デバッグなしで実行</b>しますと、以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/3006a.jpg" width="80%"/>
<p>図3006a</p>
<p>&nbsp;</p>
　まず、女の子の方がプレイヤーです。コントローラで操作できます。こちらは、３Ｄ空間上に<b>SpriteStdio5データ</b>を<b>３Ｄ上の厚さのない壁</b>のように展開しています。これまで出てきた<b>Squareメッシュのようなもの</b>だと思ってください。（以降便宜上、<b>スクエアメッシュ</b>といいます。）<br />
　それに対して手前で行ったり来たりしている<b>卵型のキャラクター</b>は<b>スプライト</b>として展開しています。<br />
　この両者の違いは、<b>スクエアメッシュ</b>は３Ｄ上の板、なので斜めから見ることもできます。遠近法も使えます。<b>スプライト</b>は、スクリーン上の位置で操作しますので奥行はありません。二つ以上のオブジェクトが重なることはありますが、遠近法は使えません。<br />
<br />
　それでは、コントローラで操作してみましょう。左スティックを左右に倒すと、女の子が移動します。スティックを左右に完全に倒すと、アニメーションが変わります。ボックスに当たると自動的に反発します。<br />
　移動中Ａボタンでジャンプできます。ボックスの上に乗ることができます。走ってる間なら、Ｂボタンで攻撃できます。<br />
　ボックスに乗ってない状態で、左スティックを手前か奥に倒すと、<b>レール</b>を移動します。<br />
　この３Ｄ空間は、<b>横に５本のレール</b>が引かれていると思ってください。奥に向かって並んでいます。<br />
　女の子はレール上しか横移動できません。ボックスがない場所だとレールを変更することができます。レール変更中は何も操作はできません。<br />
　以下の画面は、女の子がボックスの上で<b>攻撃</b>しているアニメーションです。<br/>
　攻撃アニメーションは少しスピードを速くしています（40fps）。
<p>&nbsp;</p>
<img src="img/3006b.jpg" width="80%"/>
<p>図3006b</p>
<br />
<h4>ソース解説</h4>
　それではソースを細かく見ていきましょう、<br />
　まず、卵型のキャラクターから見ていきます。<b>Charactor.h、Charactor.cpp</b>に宣言と実体があります。以下が宣言部です。<br />
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class EggAnime :  public SS5ssae;
    //  用途: 卵のアニメーション
    //--------------------------------------------------------------------------------------
    class EggAnime : public SS5ssae{
        float m_Span;
    public:
        //構築と消滅
        EggAnime(const shared_ptr&lt;Stage>& StagePtr, const wstring& BaseDir);
        virtual ~EggAnime();
        //初期化
        virtual void Create() override;
        virtual void Update()override;
    };
</pre>
</div>
　<b>SpriteStdioデータ</b>は<b>SS5ssaeクラス</b>の派生クラスとして作成します。<br />
　ライブラリ中では、<b>SpriteStudio5.hおよびSpriteStudio5.cpp</b>に<b>SS5ssaeクラス</b>は記述されています。
　ご覧のように、いたってシンプルです。<b>コンストラクタとデストラクタ、そしてCreate()、Update()仮想関数</b>があるだけです。<br/>
　親クラスである、<b>SS5ssaeクラス</b>は<b>GameObjectの派生クラス</b>です。<b>EggAnimeクラス</b>は、その派生クラスとして作成するので、そのままステージ上に<b>AddGameObject</b>できます。<br />
　<b>GameObjectの派生クラス</b>ですので、<b>Transform</b>はデフォルトで持っています。つまりアニメーション全体の移動や回転は、<b>Transform</b>を操作することで実装します。<br />
<br />
　以下が、<b>EggAnimeクラス</b>の実体です。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class EggAnime :  public SS5ssae;
    //  用途: 卵のアニメーション
    //--------------------------------------------------------------------------------------
    //構築と消滅
    EggAnime::EggAnime(const shared_ptr&lt;Stage>& StagePtr, const wstring& BaseDir) :
        <span class="red">SS5ssae(StagePtr, BaseDir, L"character_template_2head.ssae", L"attack1", true),</span>
        m_Span(10.0f)
    {}
    EggAnime::~EggAnime(){}
    //初期化
    void EggAnime::Create(){
        <span class="red">//元となるオブジェクトからアニメーションオブジェクトへの行列の設定
        Matrix4X4 mat;
        mat.DefTransformation(
            Vector3(1.0f, 1.0f, 1.0f),
            Vector3(0, 0, 0),
            Vector3(0, 0, 0)
            );
        SetToAnimeMatrix(mat);</span>

        //位置の初期化
        auto PtrT = GetComponent&lt;Transform>();
        PtrT->SetPosition(Vector3(0, -25.0f, 0.2f));
        //親クラスのCreateを必ず呼ぶ
        <span class="red">SS5ssae::Create();</span>
        //値は秒あたりのフレーム数
        SetFps(30.0f);
        //スプライトのサイズ（1メートル当たりのピクセル）
        SetSpritePixelParMeter(8.0f);
    }
    void EggAnime::Update(){
        float ElapsedTime = App::GetApp()->GetElapsedTime();

        auto PtrT = GetComponent&lt;Transform>();
        auto Pos = PtrT->GetPosition();
        Pos.x += (m_Span * ElapsedTime);
        if (abs(Pos.x) > 40.0f){
            m_Span *= -1.0f;
        }
        PtrT->SetPosition(Pos);
        <span class="red">//移動方向に向きを変える
        if (span &lt; 0){
            PtrT->SetScale(1, 1, 1);
        }
        else{
            PtrT->SetScale(-1, 1, 1);
        }
        //アニメーションを更新する
        UpdateAnimeTime(ElapsedTime);</span>
    }
</pre>
</div>
　行ったり来たりしているだけなので、そんなに分量はありません。<br />
　重要なのは、コンストラクタで親クラスに渡しているパラメータです。
<div class="box1">
<pre>
    EggAnime::EggAnime(const shared_ptr&lt;Stage>& StagePtr, const wstring& BaseDir) :
        <span class="red">SS5ssae(StagePtr, BaseDir, L"character_template_2head.ssae", L"attack1", true),</span>
　　//中略
</pre>
</div>
　親クラスに渡さなければいけないのは、<br /><b>
１、ステージのポインタ:　ここでは、StagePtr<br />
２、基準ディレクトリ:　SpriteStdioデータがあるディレクトリです。この値はステージから渡されるようにしてあります。<br />
３、SpriteStdioデータファイル名: L"character_template_2head.ssae"を渡してます。<br />
４、初期アニメーション名: L"attack1"を渡してます。<br />
５、スプライト版か、スクエアメッシュか: スプライトならtrueです。<br />
</b>
　です。<br/>
<br />
　コンストラクタの後は<b>Create()関数</b>ですが、
<div class="box1">
<pre>
        <span class="red">//元となるオブジェクトからアニメーションオブジェクトへの行列の設定
        Matrix4X4 mat;
        mat.DefTransformation(
            Vector3(1.0f, 1.0f, 1.0f),
            Vector3(0, 0, 0),
            Vector3(0, 0, 0)
            );
        SetToAnimeMatrix(mat);</span>
</pre>
</div>
　は、データと、展開するゲーム環境との差を埋める行列です。ここではあまり問題にはなりませんが、<b>後で出てくる女の子キャラ</b>では、かなり重要です。<br />
　この設定は、デザイナーさんなどが作成したデータが<b>思った時より大きい、とか、思ったより小さい</b>ときの、修正中の緊急避難的にも使用できます。<br />
　もう一つ注意点は
<div class="box1">
<pre>
        //親クラスのCreateを必ず呼ぶ
        <span class="red">SS5ssae::Create();</span>
</pre>
</div>
　の記述で、親クラスの<b>Create()関数</b>を必ず呼びだすことです。仮想関数は、派生クラスで多重定義すると、親クラスの関数は呼ばれることはありません。（仮想デストラクタだけは例外）。<br/>
　<b>SS5ssae::Create();</b>では、データの読み取りを行うので、これを記述しないと何にもなりません（ヌルポインタのエラーになり、固まります）。<br/>
　続いての設定は再生スピードです。再生スピードはデータ側にも設定されているのですが、ゲームに実装する場合、動的に変更する場合があります。また、スピードを極端に遅くして（たとえば5.0とか）再生してみて、何かエラーがないかなど検証にも使えます。ここでは、データと同じ30.0を指定しています。<br />
　そのあとの、<b>スプライトのサイズ（1メートル当たりのピクセル）</b>も、どちらかというとデータをゲーム環境に合わせるための設定です。<br />
　そのほかの<b>Create()関数での設定</b>は、通常のGameObjectと同じです。<b>Transformコンポーネント</b>の値を設定しています。<br />
<br/>
　Update()関数で注意すべき点は、<b>向きを変える処理</b>と<b>アニメーションの更新</b>です。<br />
　向きを変えるのには、<b>スケーリングのXを-1にする</b>ことで実装可能です。<br />
　でも、これができるのは、卵キャラだけで、あとで説明する女の子キャラでは使えません。<br />
　また、<b>UpdateAnimeTime(ElapsedTime);</b>で、ターン時間を渡してアニメーションを更新します。これを呼び出さないと、アニメーションが進みません（表示されないこともあります）。<br />
<br />
　このように、実際にアニメーションを実装するだけなら比較的簡単にできます。<br />
<br />
<h4>プレイヤーの操作</h4>
　プレイヤーは<b>Player.hとPlayer.cpp</b>に記述があります。<br />
　以下はヘッダの宣言部です。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class Player :  public SS5ssae;
    //  用途: プレイヤー
    //--------------------------------------------------------------------------------------
    class Player : public SS5ssae{
        shared_ptr&lt; StateMachine&lt;Player> >  m_StateMachine;   //ステートマシーン
        //移動の方向を得る
        float GetMoveX();
        //最高速度
        float m_MaxSpeed;
        //減速率
        float m_Decel;
        //質量
        float m_Mass;
        //Zレールの位置の配列
        vector&lt;float> m_ZRail;
        size_t m_ZRailIndex;
        //一つ前のレール
        size_t m_ZRailBeforIndex;
        //丸影を作成するためのメッシュ
        shared_ptr&lt;CommonMeshResource> m_ShadowResource;
        //データとゲームとの変換行列
        Matrix4X4 m_ToAnimeMatrixLeft;
        Matrix4X4 m_ToAnimeMatrixRight;
    public:
        //構築と破棄
        Player(const shared_ptr&lt;Stage>& StagePtr, const wstring& BaseDir);
        virtual ~Player(){}
        //初期化
        virtual void Create() override;
        //アクセサ
        shared_ptr&lt; StateMachine&lt;Player> > GetStateMachine() const{
            return m_StateMachine;
        }
        //モーションを実装する関数群
        //移動して向きを移動方向にする
        //移動距離を返す
        float MoveRotationMotion();

        void AnimeChangeMotion(const wstring& key, bool looped);
        void LoopedAnimeUpdateMotion();

        //Aボタンでジャンプするどうかを得る
        bool IsJumpMotion();
        //ジャンプスタート処理
        void JumpStartMotion();
        //ジャンプしている間の処理
        //ジャンプ終了したらtrueを返す
        bool JumpMotion();

        //Bボタンでアタックするどうかを得る
        bool IsAttackMotion();
        //Bボタンでアタックする処理
        bool AttackMotion();

        //左スティックでZレールを変更するかどうか
        bool IsRailChangeMotion();
        //Zレール変更を開始する
        void RailChangeStartMotion();
        //Zレール変更を更新する
        bool RailChangeMotion();
        //Zレールを強制的に戻す
        void RailChangeBeforStartMotion();
        //Zレール変更を終了する
        void RailChangeEndMotion();

        //更新
        virtual void Update() override;
        virtual void Update2() override;
    };
</pre>
</div>
　ご覧のように、<b>ステートマシン</b>があり、数多くの<b>モーション関数</b>があります。<br />
　さらに<b>Player.h</b>には、これらのモーション関数を呼び出す<b>ステート</b>が6種類あります。<br />
　<b>モーション関数</b>はこのフレームワークあるいはC++授業特有の呼び名で、詳しくは、<a href="00_06.html">００６．ステートと速度を調整するプレイヤー</a>を参照してください。<br />
　このプレイヤーのステートとモーション関数の関係は以下のようになってます。
<table>
<tr>
<th width="20%">ステート名</th>
<th width="20%">内容</th>
<th width="60%" colspan="2">呼ばれるモーション関数（可能性含む）、ChangeState()は省略</th>
</tr>
<tr>
<td rowspan="3">WaitState</td>
<td rowspan="3">待機状態</td>
<td width="15%">Enter</td>
<td>AnimeChangeMotion(L"wait", true)</td>
</tr>
<tr>
<td>Execute</td>
<td>
LoopedAnimeUpdateMotion()<br/>
IsRailChangeMotion()<br/>
MoveRotationMotion()<br />
</td>
</tr>
<tr>
<td>Exit</td>
<td>&nbsp;</td>
</tr>

<tr>
<td rowspan="3">RailChangeState</td>
<td rowspan="3">レール変更</td>
<td width="15%">Enter</td>
<td>
AnimeChangeMotion(L"charge", true)<br/>
RailChangeStartMotion()
</td>
</tr>
<tr>
<td>Execute</td>
<td>
LoopedAnimeUpdateMotion()<br/>
RailChangeMotion()<br/>
</td>
</tr>
<tr>
<td>Exit</td>
<td>RailChangeEndMotion()</td>
</tr>

<tr>
<td rowspan="3">WalkState</td>
<td rowspan="3">通常移動</td>
<td width="15%">Enter</td>
<td>AnimeChangeMotion(L"walk", true)</td>
</tr>
<tr>
<td>Execute</td>
<td>
LoopedAnimeUpdateMotion()<br/>
IsRailChangeMotion()<br/>
MoveRotationMotion()<br />
IsJumpMotion()
</td>
</tr>
<tr>
<td>Exit</td>
<td>&nbsp;</td>
</tr>

<tr>
<td rowspan="3">RunState</td>
<td rowspan="3">走る状態</td>
<td width="15%">Enter</td>
<td>AnimeChangeMotion(L"run",true)</td>
</tr>
<tr>
<td>Execute</td>
<td>
LoopedAnimeUpdateMotion()<br/>
MoveRotationMotion()<br />
IsAttackMotion()<br />
IsJumpMotion()
</td>
</tr>
<tr>
<td>Exit</td>
<td>&nbsp;</td>
</tr>

<tr>
<td rowspan="3">JumpState</td>
<td rowspan="3">ジャンプ状態</td>
<td width="15%">Enter</td>
<td>AnimeChangeMotion(L"jump_all", false)<br/>
JumpStartMotion()
</td>
</tr>
<tr>
<td>Execute</td>
<td>
MoveRotationMotion()<br/>
</td>
</tr>
<tr>
<td>Exit</td>
<td>&nbsp;</td>
</tr>

<tr>
<td rowspan="3">AttackState</td>
<td rowspan="3">アタック状態</td>
<td width="15%">Enter</td>
<td>AnimeChangeMotion(L"attack2", false)<br/>
SetFps(40.0f)
</td>
</tr>
<tr>
<td>Execute</td>
<td>
MoveRotationMotion()<br/>
</td>
</tr>
<tr>
<td>Exit</td>
<td>SetFps(30.0f)</td>
</tr>


</table>
　この表を見ると、ステートによって、できることが違うことがわかると思います。<br />
　たとえば、攻撃する（攻撃状態にに移行する）ことができるのは、走る状態（RunState）のときだけです。<br />
　かわりに、レール変更は、待機状態（WaitState）か通常移動（WalkState）のときだけです。<br />
　一方、ジャンプ中や攻撃中、レール移動中の場合、かなりできることは制限されています。<br />
　プレイヤーの動きを細かく制御しようとすればするほど、「○○のとき、もし××があったら▲▲を行う」のような処理がどんどん増えていきます。<br />
　これを<b>if文やswitch文</b>で制御するとなると大変なことになります。どこかで「抜け」ができてしまう可能性が高くなります。<br />
　そういう意味でも、ステートによる処理の振り分けは、効率が良いものになります。また、処理を増やすことも簡単です。一つステートを作成し、関連するモーション関数を作成し、どのタイミングで、その処理に移行するのかのみ考えればいいのです。<br />
<br />
<h4>PlayerのコンストラクタとCreate関数</h4>
　それでは、プレイヤーの実体を見ていきます。<br />
　コンストラクタは以下のような記述です。
<div class="box1">
<pre>
    Player::Player(const shared_ptr&lt;Stage>& StagePtr, const wstring& BaseDir) :
        <span class="red">SS5ssae(StagePtr, BaseDir, L"character_template_3head.ssae", L"wait"),</span>

//中略
    {
        m_ZRail = { 0, 2.0f, 4.0f, 6.0f, 8.0f };
        <span class="red">m_ToAnimeMatrixLeft.DefTransformation(
            Vector3(0.1f, 0.1f, 0.1f),
            Vector3(0, 0, 0),
            Vector3(0, -0.55f, 0.0f)
            );
        m_ToAnimeMatrixRight.DefTransformation(
            Vector3(-0.1f, 0.1f, 0.1f),
            Vector3(0, 0, 0),
            Vector3(0, -0.55f, 0.0f)
            );</span>

    }
</pre>
</div>
　メンバイニシャライザ内の、親クラスのコンストラクタを呼ぶところは、卵型と違うところが、1か所だけあります。最後の引数です（つまりスプライトかどうかのフラグ）。<br />
　卵型は<b>true</b>を渡していましたが、こちらは何も渡してません。このフラグは><b>デフォルト引数</b>になっているので、指定しなければ、自動的に<b>スクエアメッシュ</b>になります。<br />
　また、関数内部の、<b>m_ToAnimeMatrixLeft、m_ToAnimeMatrixRight</b>の設定は、向きが変わるときに、<b>Transformで。スケーリングのXをマイナスにする</b>の手法をとれない場合の処理です。<br />
　プレイヤーは衝突判定や、自動反発がついていいますので、Transformは回転する場合は（このサンプルでは回転してませんが）、回転行列を使う必要があります。<br />
<br />
　続いて、Create()関数ですが、<b>スクエアメッシュ</b>なので、スプライト版のときとは少し違います。<br />
　自動衝突判定（CollisionObb）、Rigitbody、Gravityがコンポーネントに追加されています。また影もついています。<br />
　影は、実は、SpriteStdioのデータ内に入っています。（卵型を見ていただくとわかると思います。卵型で表示している影はデータ内のものです）。同様のものが、女の子キャラにもあります。<br />
　しかし、３Ｄ空間に配置した場合、どうしても違和感があるので丸影をつけています。丸影は、
<div class="box1">
<pre>
        //影の形（メッシュ）を設定
        ShadowPtr->SetMeshResource(m_ShadowResource);
</pre>
</div>
　という記述で作成します（メンバ変数として保管します）。<br />
　また、動作補助として<b>Action</b>をつけています。これは、<b>レール間を移動する</b>場合に、<b>MoveTo</b>を使っているためで、Create時は無効にしておきます（移動処理は通常は<b>RigitbodyとGravity</b>を使うため）。<br />
　あとはカメラですが、サンプルによく登場する<b>LookAtCamera</b>を修正したものを利用します。<b>MyCamera</b>といい<b>GameStage.hとGameStage.cpp</b>に宣言定義されています。<br />
　Create()関数では、最後にステートマシンを初期化しています。<br />
<br />
　Create()関数には、ところどころコメントになってるコードがありますが、１か所目は衝突判定に、<b>CollisionSphere</b>を使う場合はObbをコメントにしてこちらを有効にします。<br />
　また、衝突判定の設定で<b>SetDrawActive(true)</b>としますと、衝突判定ボリュームをワイヤフレームで表示します（ジャンプしたりする、乗れるボックスもワイヤフレームが表示されているので同様です）、表示させると以下のようになります。
<p>&nbsp;</p>
<img src="img/3006c.jpg" width="80%"/>
<p>図3006c</p>
　以下は、衝突判定に、<b>CollisionSphere</b>を使い、ワイアフレームを表示させた場合です。
<p>&nbsp;</p>
<img src="img/3006d.jpg" width="80%"/>
<p>図3006d</p>
　また、カメラを、現在の<b>MuCamera</b>から、<b>LookAtCamera</b>にする場合は、
<div class="box1">
<pre>
        //0番目のビューのカメラを得る
        //MyCameraである
//      auto PtrCamera = dynamic_pointer_cast&lt;MyCamera>(GetStage()->GetCamera(0));
        //LookAtCameraである
        auto PtrCamera = dynamic_pointer_cast&lt;LookAtCamera>(GetStage()->GetCamera(0));
</pre>
</div>
　のように、<b>MuCamera</b>をコメントにして<b>LookAtCamera</b>を有効にした後、<b>GameStage.cpp</b>の<b>GameStage::CreateViews()関数内</b>で、
<div class="box1">
<pre>
        //最初のビューにパラメータの設定
//      PtrView->ResetParamaters&lt;MyCamera, 
            MultiLight>(rect, Color4(0.0f, 0.125f, 0.3f, 1.0f), 1, 0.0f, 1.0f);
        PtrView->ResetParamaters&lt;LookAtCamera, 
            MultiLight>(rect, Color4(0.0f, 0.125f, 0.3f, 1.0f), 1, 0.0f, 1.0f);
</pre>
</div>
　のように、ビューの設定の<b>MuCamera</b>をコメントにして<b>LookAtCamera</b>を有効にします。<br />
　すると、コントローラで画面を回転できるようになります。カメラを回転させて、斜めにしてみると
<p>&nbsp;</p>
<img src="img/3006e.jpg" width="80%"/>
<p>図3006e</p>
　のような画面になります。３Ｄ上の位置関係が一目瞭然ですね。卵型と女の子の、スプライトかスクエアメッシュかの違いも確認できます。<br/>
<br/>
　このように、カメラを切り替えたり、衝突判定を切り替えたりしながら、制作を進めていくと、デバッグも楽になります。ぜひ利用してみてください。<br />
<br />
　Create()関数の最後に、ステートマシンの初期化があります。
<div class="box1">
<pre>
        //ステートマシンの構築
        m_StateMachine = make_shared&lt; StateMachine&lt;Player> >(GetThis&lt;Player>());
        //最初のステートをWaitStateに設定
        m_StateMachine->SetCurrentState(WaitState::Instance());
        //WaitStateの初期化実行を行う
        m_StateMachine->GetCurrentState()->Enter(GetThis&lt;Player>());
</pre>
</div>
　このように、最初のステートは<b>WaitState</b>ということになります。<br />
<br />
<h4>Playerのそのほかの関数</h4>
　このほかには、<b>Update()、Update2()仮想関数</b>を多重定義しています。<br />
　<b>Update()</b>はステートを使っているのでシンプルです。
<div class="box1">
<pre>
    void Player::Update(){
        //ステートマシンのUpdateを行う
        //この中でステートの切り替えが行われる
        m_StateMachine->Update();
    }
</pre>
</div>
　<b>Update2()</b>についても複雑ではありません。<b>Update2()</b>は、衝突後の相手を調べるなどの処理で、Rigidbody自動反発では対応外の部分を補足処理してます（あと、FPSの表示もしてますね）。<br />
<br />
　このように、ほとんどの処理は、<b>ステートとモーション関数群</b>に任せられることになります。<br />
　<b>ステートとモーション関数の関係</b>は上記で表で説明したので、それぞれの中身の解説は省略します。<br />
　各モーション関数は、<b>一つの細かい操作を行うように記述する</b>、のがポイントです。<br />
　「ついでにここに書いちゃえ」などと、関数の役割や目的と離れた処理を、記述しないようにしましょう。決して欲張ってはいけません。一つの関数を、細かな役割単位に分割することで、<b>構造的なプログラミング</b>が可能になります。
<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="index.html">目次</a></li>
<li><a href="30_07.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
