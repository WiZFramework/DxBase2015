<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３０１．スプライトとスクエア</h3>
<br />
<h4>スプライトとスクエアの違い</h4>
　<b>DxBase2015</b>は、平面の表現に<b>スプライトとスクエア</b>という2つの方式を持ってます。<br />
　<b>スプライト</b>は2次元上の平面です。ですので、座標系はスクリーンそのものが基準になります。<br/>
　それに対して、<b>スクエア</b>は3次元上の平面です。厚みはありませんが、回転したり、遠近法を使って描画することができます。<br />
　まず、この違いを理解しましょう。<br/>
<br />
　<b>Sample301</b>を開いて、リビルド実行すると以下のような画面が現れます。ベースになってるのはチュートリアル008ですが、数字とかバー（左下）に出現します。また、追いかけるオブジェクトが自分のナンバーを抱えてます。
<p>&nbsp;</p>
<img src="img/3001a.jpg" width="80%"/>
<p>図3001a</p>
<p>&nbsp;</p>
　まず、左下のバーと数字が<b>スプライト</b>です。カメラを変化させてもそこから動きません。<br />
　それに対して、追いかけるオブジェクトについている数字はカメラを動かすと表示位置が変化します。そして、追いかけるオブジェクトはたとえば上から見ると上からの視点になりますが、数字は常にカメラの方向を向いてます。<br />
<br />
<h4>数字スプライト</h4>
　これらのオブジェクトは<b>Charactor.h、cpp</b>に記述されています。数字のスプライトは<b>NumberSprite</b>クラスです。<br />
　以下は<b>Create()関数</b>です。オブジェクトをスプライトにするためには<b>Spriteコンポーネント</b>を実装します。<br />
　また、いくつかのSprite特有の設定をします。
<div class="box1">
<pre>
    //初期化
    void NumberSprite::Create(){

        //中略

        //スプライトをつける
        auto PtrSprite = AddComponent&lt;Sprite>(Color4(1.0f, 1.0f, 1.0f, 1.0f));
        PtrSprite->SetTextureResource(L"NUMBER_TX");
        //1メートル当たりのピクセル数
        //以下は640*480ピクセルの場合。横幅20,縦15メートルということ
        PtrSprite->SetPixelParMeter(32.0f);
        //透明処理
        SetAlphaActive(true);
        //中心原点
        PtrSprite->SetCoordinate(Sprite::Coordinate::m_CenterZeroPlusUpY);
        //各数字ごとにUV値を含む頂点データを配列化しておく
        for (size_t i = 0; i &lt; 10; i++){
            float from = ((float)i) / 10.0f;
            float to = from + (1.0f / 10.0f);
            vector&lt;VertexPositionColorTexture> NumVirtex =
            {
                //左上頂点
                VertexPositionColorTexture(
                Vector3(-0.5f, 0.5f, 0),
                Color4(1.0f, 1.0f, 1.0f, 1.0f),
                Vector2(from, 0)
                ),
                //右上頂点
                VertexPositionColorTexture(
                Vector3(0.5f, 0.5f, 0),
                Color4(1.0f, 1.0f, 1.0f, 1.0f),
                Vector2(to, 0)
                ),
                //左下頂点
                VertexPositionColorTexture(
                Vector3(-0.5f, -0.5f, 0),
                Color4(1.0f, 1.0f, 1.0f, 1.0f),
                Vector2(from, 1.0f)
                ),
                //右下頂点
                VertexPositionColorTexture(
                Vector3(0.5f, -0.5f, 0),
                Color4(1.0f, 1.0f, 1.0f, 1.0f),
                Vector2(to, 1.0f)
                ),
            };
            m_NumberBurtexVec.push_back(NumVirtex);
        }


    }
</pre>
</div>
　このオブジェクトは、<b>NUMBER_TX</b>というテクスチャを持ちます。数字が0から10まで並んでいるテクスチャで、これを経過時間に合わせて表示するUV値を変えます。それを配列化しているわけです。<br />
　実際の数字の切り替えは以下のように<b>Update()関数</b>で行ってます。
<div class="box1">
<pre>
    void NumberSprite::Update(){
        //前回のターンからの時間
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        m_TotalTime += ElapsedTime;
        size_t Num = (size_t)m_TotalTime;
        Num = Num % 10;
        <span class="red">auto PtrSprite = GetComponent&lt;Sprite>();
        PtrSprite->UpdateVirtexBuffer(m_NumberBurtexVec[Num]);</span>
    }
</pre>
</div>
　赤くなってるところは、動的にSpriteの頂点を変更しているところです。Create()時に作成した配列のその数字に対応するインデックスを渡してます。<br/>
<br />
<h4>バースプライト</h4>
　数字スプライトの左側にあるバーは、ライフとか時間経過とかに利用できるインターフェイスです。<b>BarSpriteクラス</b>がその実装です。数字スプライトと同じように、<b>Spriteコンポーネント</b>を実装します。<br />
　以下は、Create()関数で、このオブジェクト特有の処理をしているところです。
<div class="box1">
<pre>
    //初期化
    void BarSprite::Create(){

        //中略

        //原点左下
        PtrSprite->SetCoordinate(Sprite::Coordinate::m_LeftBottomZeroPlusUpY);

        vector&lt;VertexPositionColorTexture> Virtex =
        {
            //左上頂点
            VertexPositionColorTexture(
            Vector3(-0.5f, 4.0f, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(0, 0)
            ),
            //右上頂点
            VertexPositionColorTexture(
            Vector3(0.5f, 4.0f, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(1.0f, 0)
            ),
            //左下頂点
            VertexPositionColorTexture(
            Vector3(-0.5f, 0.0f, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(0, 1.0f)
            ),
            //右下頂点
            VertexPositionColorTexture(
            Vector3(0.5f, 0.0f, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(1.0f, 1.0f)
            ),
        };
        PtrSprite->UpdateVirtexBuffer(Virtex);
    }
</pre>
</div>
　ここでは、バーの上げ下げを<b>頂点を変更することで</b>実装してます。初期値は高さが4.0になってます。また、座標系を、<b>左下原点</b>で実装します。こうしておくことで、左下をそろえて表示することができます。<br />
　以下は<b>Update()関数</b>です。動的に頂点を変更しています。
<div class="box1">
<pre>
    void BarSprite::Update(){
        //前回のターンからの時間
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        m_LastTime -= ElapsedTime;
        if (m_LastTime &lt; 0.0f){
            m_LastTime = m_MaxTime;
        }
        float BarVirtexHeight = m_LastTime * 4.0f / m_MaxTime;
        float UVHeight = 1.0f - (m_LastTime / m_MaxTime);
        auto PtrSprite = GetComponent&lt;Sprite>();
        vector&lt;VertexPositionColorTexture> Virtex =
        {
            //左上頂点
            VertexPositionColorTexture(
            Vector3(-0.5f, BarVirtexHeight, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(0, UVHeight)
            ),
            //右上頂点
            VertexPositionColorTexture(
            Vector3(0.5f, BarVirtexHeight, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(1.0f, UVHeight)
            ),
            //左下頂点
            VertexPositionColorTexture(
            Vector3(-0.5f, 0.0f, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(0, 1.0f)
            ),
            //右下頂点
            VertexPositionColorTexture(
            Vector3(0.5f, 0.0f, 0),
            Color4(1.0f, 1.0f, 1.0f, 1.0f),
            Vector2(1.0f, 1.0f)
            ),
        };
        PtrSprite->UpdateVirtexBuffer(Virtex);
    }
</pre>
</div>
　このように、SpriteはスケーリングやUV値で大きさや表示するテクスチャ内の部分を指定できますが
、直接頂点を変更しても実装できます。<br />
　計算方法やテクスチャの形によって、柔軟に考えるとよいでしょう。<br />
<br />
<h4>数字のスクエア</h4>
　ここまで2つはスプライトでしたが、最後に、追いかけるオブジェクトの上に表示される番号です。これは、<b>スクエア</b>を使って実装します。<b>NumberSquare</b>が実装クラスです。<br />
　以下は、<b>Create()関数</b>です。コンストラクタで、関連づけられる追いかけるオブジェクトのポインタが渡されています。このクラス内では<b>weak_ptr</b>として保持しています。<b>m_SeekObject</b>が変数名です。
<div class="box1">
<pre>
    void NumberSquare::Create(){
        if (!m_SeekObject.expired()){

            //中略
            <span class="red">//変更できるスクエアリソースを作成
            m_SquareMeshResource = CommonMeshResource::CreateSquare(1.0f, true);</span>

        }
    }
</pre>
</div>
　まず、<b>m_SeekObject</b>が有効かどうか確認します。無効であればスクエアは作成しません。<br />
　ここでは、<b>Transform</b>を<b>m_SeekObject</b>に合わせて初期化した後、<b>頂点を変更できるスクエア</b>を作成して、それをメッシュリソースにしています。ここでは、メッシュはアプリケーションに登録してません。それは頂点が変更されるので、共有が難しいからです。<br />
　以下はUpdate()関数です。ここではちょっと珍しい処理をしています。
<div class="box1">
<pre>
    void NumberSquare::Update(){
        if (!m_SeekObject.expired()){
            auto SeekPtr = m_SeekObject.lock();
            auto SeekTransPtr = SeekPtr->GetComponent&lt;Transform>();

            auto PtrTransform = GetComponent&lt;Transform>();
            auto Pos = SeekTransPtr->GetPosition();
            Pos.y += 0.75f;
            PtrTransform->SetPosition(Pos);
            PtrTransform->SetScale(1.0f, 1.0f, 1.0f);

            auto PtrCamera = GetStage()->GetCamera(0);

            Quaternion Qt;
            //向きをビルボードにする
            Qt.Billboard(PtrCamera->GetAt() - PtrCamera->GetEye());

            //向きをフェイシングにする場合は以下のようにする
            //  Qt.Facing(Pos - PtrCamera->GetEye());
            //向きをフェイシングYにする場合は以下のようにする
            //  Qt.FacingY(Pos - PtrCamera->GetEye());
            //向きをシークオブジェクトと同じにする場合は以下のようにする
            // Qt = SeekTransPtr->GetQuaternion();

            PtrTransform->SetQuaternion(Qt);

            vector&lt;VertexPositionNormalTexture> BackupVec;
            //リソースのバックアップをコピー
            //std::は必要ないが、確認のため記述
            std::copy(
                m_SquareMeshResource->GetBackupVertices().begin(),
                m_SquareMeshResource->GetBackupVertices().end(),
                back_inserter(BackupVec)
                );
            //上記は以下のようにも書ける
            //for (size_t i = 0; i &lt; m_SquareMeshResource->GetBackupVertices().size(); i++){
            //  BackupVec.push_back(m_SquareMeshResource->GetBackupVertices().at(i));
            //}

            //UV値の変更
            float from = ((float)m_Number) / 10.0f;
            float to = from + (1.0f / 10.0f);
            //左上頂点
            BackupVec[0].textureCoordinate = Vector2(from, 0);
            //右上頂点
            BackupVec[1].textureCoordinate = Vector2(to, 0);
            //左下頂点
            BackupVec[2].textureCoordinate = Vector2(from, 1.0f);
            //右下頂点
            BackupVec[3].textureCoordinate = Vector2(to, 1.0f);
            //変更した頂点にアップデート
            m_SquareMeshResource->UpdateVirtexBuffer(BackupVec);

        }
    }
</pre>
</div>
　ここでは、<b>Transformの回転</b>を決定するのに、
<div class="box1">
<pre>
    //向きをビルボードにする
    Qt.Billboard(PtrCamera->GetAt() - PtrCamera->GetEye());
</pre>
</div>
　という処理を行ってます。<b>Quaternion</b>には、<b>Billboard</b>というメンバ関数があり、この関数に、カメラ位置と、カメラ注目点を渡すと、それと直行した角度を返します。<br />
　このほかに、<b>Quaternion</b>には<b>Facing()、FacingY()</b>があり、それぞれ<b>完全にカメラを向く、とY軸だけカメラを向く</b>という角度を計算します。<br />
　<b>Transformの回転</b>には、その結果を渡すことができます。<br />
　この処理で、番号スクエアは常に、カメラに視線と直角に見えるように表示できます。<br />
　この<b>ビルボード、フェイシング、フェイシングY</b>はパーティクルエフェクトでも重要になりますので覚えておきましょう。

<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="index.html">目次</a></li>
<li><a href="30_02.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
