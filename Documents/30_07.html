<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３０７．メニューでのSpriteStdio5データの活用（学生サンプル）</h3>
<br />
　このサンプルはWiZの学生<b>荻野 彩樹君、古川 拓也君</b>が作成した、<b>SpriteStdio5データ</b>を使った<b>メニュー</b>のサンプルです。<br />
　ここでは、<b>ステートと項目選択用のSpriteStdio5データ</b>を組み合わせることにより、すっきりとして可読性が高い実装を実現しています。<br/>
<br />
<h4>メニューの操作方法</h4>
　<b>Sample307ディレクトリ</b>内のソリューションを開き、「リビルド」「デバックなしで実行」すると、オープニングアニメーションを経て、以下の画面が現れます。<br />
　汎用性が高いので、実際に自分のゲームにメニューを実装する際も、大いに参考になるでしょう。
<p>&nbsp;</p>
<img src="img/3007a.jpg" width="80%"/>
<p>図3007a</p>
<p>&nbsp;</p>
　コントローラの左スティックを上下するとメニューが切り替わります。<br />
　速度が速いのでちょっと見ると見過ごしてしまいますが、メニューが切り替わる際も短いアニメーションが再生されて、選択項目が切り替わります。また、項目移動や決定時に、サウンドも実装されています。<br />
　Aボタンで、選択されたステージが呼ばれるという想定ですが。サンプルで呼ばれるのは、どの選択でも<b>３０６．SpriteStdio5データの再生と操作</b>で紹介したステージです。<br />
　ゲーム画面になった後は、<b>Bボタンでメニューに戻り</b>ます。
<br/>
<h4>SpriteStdio5データの内容</h4>
　このメニューステージが読み込んでいる<b>SpriteStdio5データ</b>は１つです。<b>media/StageSelect/StageSelect.ssae</b>です。<br />
　この中に、いくつもの種類のアニメーションが、細かく小分けされて実装されています。<br />
　すなわち<b>「オープニング」「メニュー１が選択されている状態」「メニュー１からメニュー２に移動している状態」「メニュー２が選択されている状態」．．．</b>のような形です。<br />
　これを、<b>ステート</b>によって振り分けて再生しています。<br />
<br />
<h4>オープニングから、メニュー１が選択されている状態まで</h4>
　以下は、オープニングアニメーションのステートです。メニューは<b>StageSelectAnimation.h、cpp</b>に実装されていて、オープニングは<b>OpeningState</b>です。<b>Execute()関数</b>のみ実装されています。<br/><div class="box1">
<pre>
    void OpeningState::Execute(const shared_ptr&lt;StageSelectAnimation>& Obj)
    {
        if( Obj->IsAnimeEnd() ) {
            Obj->GetStateMachine()->ChangeState( OpenToStage1State::Instance() ) ;
        }
    }
</pre>
</div>
　このように、アニメーションの終了を待って、次のステート<b>OpenToStage1State</b>に移行しています。<br />
　ここから呼び出している<b>IsAnimeEnd()関数</b>は、これまでも説明してきた<b>モーション関数</b>です。<b>今実行しているアニメーションが終了したかどうか</b>を調べます。実装されてるアニメーションは選ばないので、汎用的に使用できます。<br />
　このように<b>項目移動用のアニメーションと連動するステート</b>は同様の構造になっています。<br />
<br />
<h4>項目の選択</h4>
　どこかの項目が選択されている状態で、<b>Aボタンが押されるのをキャッチする</b>ステートの実体は以下のようになってます。<br />
　<b>メニュー１がAボタンによって選択される</b>を例に紹介します。<br />
<div class="box1">
<pre>
    void NoiseStage1State::Execute(const shared_ptr&lt;StageSelectAnimation>& Obj)
    {
        //  : コントローラ情報の取得.
        auto CntlVec = App::GetApp()->GetInputDevice().GetControlerVec();

        //  : Aボタンが押されたら.
        if ( CntlVec[0].wPressedButtons & XINPUT_GAMEPAD_A ) {
            //  : ステージを決定.
            Obj->GetStateMachine()->ChangeState( <span class="red">DecideStage1State::Instance()</span> ) ;
        }

        //  : スティックが倒されたら.
        if ( Obj->GetIsCursorMove() && CntlVec[0].fThumbLY &lt;= -Obj->GetCursorLimit() ) { 
            //  : 選択を移動.
            Obj->GetStateMachine()->ChangeState( Stage1ToStage2State::Instance() ) ;
            Obj->SetIsCursorMove( false ) ;
        }
    }
</pre>
</div>
　このように、Aボタンが押されたタイミングで、<b> DecideStage1State</b>に移行します。このステートでは<b>項目１のステージの呼び出し</b>を行います。<br />
　以下が実体です。
<div class="box1">
<pre>
    void DecideStage1State::Enter(const shared_ptr&lt;StageSelectAnimation>& Obj)
    {
        Obj->ChangeAnimation( L"Decide_Stage1" ) ;
        Obj->SetFps(60.0f);
        Obj->SetLooped( false ) ;
        Obj->PlaySE(L"Decide") ;
    }
</pre>
</div>
　ここでは、<b>Enter()関数</b>で、選択項目を決定して、1回だけサウンドを再生します。また選択アニメーションをスタートさせます。実際のステージ切り替えの処理は、<b>Excute()関数</b>で行っています。
<div class="box1">
<pre>
    void DecideStage1State::Execute(const shared_ptr&lt;StageSelectAnimation>& Obj)
    {
        if( Obj->IsAnimeEnd() ) {
            <span class="red">Obj->PostEvent(0, Obj->GetThis&lt;StageSelectAnimation>(), 
                App::GetApp()->GetSceneBase(), L"ToGame");</span>
        }   
    }
</pre>
</div>
　項目選択アニメーションの終了を待って、、ステージ以降<b>PostEvent()呼び出し</b>を行っているのがわかります。<br />
<br />
<h4>メニューの動きを小分けにする</h4>
　以上のように、このサンプルでは<b>メニューを選択する</b>というシンプルな操作を実装するのに、実に多くの処理を行っているのがわかります。<br />
　しかしこのように、アニメーションを小分けにし、対応するステートも細かく分けることで、<b>それぞれの処理を分離できる</b>ので、変更や、追加等に、素早く、バグが少なく対処できます。<br />
　メニュー項目の追加、などは、頻繁に起こります。しかし、その都度、メニューの全ソースを見直し追加項目に対応するよう記述するのは大変です。<br />
　そのためのテクニックはいろいろあるかと思いますが、今回のサンプルの例のように、<b>SpriteStdio5データとステートを組み合わせる</b>ことにより、追加前に実装されてるメニューの項目実装とは分離して作成できるので、バグも少なくなり、可読性も維持したまま実装可能です。
<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="30_06.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="30_08.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
