<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>１．更新補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>更新補助、について</h3>
　<b>更新補助</b>の章では、DxBase2015フレームワークにあらかじめ実装されている、更新系のライブラリの説明を行います。<br />
　更新補助は、大きく分けて、<b>アクション系、物理計算系、衝突判定系</b>があります。<br />
　更新処理は、<b>チュートリアル3</b>で解説したように、<b>Transformコンポーネント</b>を変化させることが基本です。しかし、ある程度決まった処理はライブラリ化することで、同じようなコードを書かずに済むこともあります。更新補助は、そんな<b>お助けマン</b>の役割をします。<br />
　そうはいっても、各オブジェクトの動きを細かく精査してくると、更新補助の処理では物足りない部分が出てきます。そういう場合は基本に立ち返り<b>Transformコンポーネント</b>を直接変化させることを検討しましょう。<br />
　また、<b>更新補助</b>を部分的に使用することも可能です。たとえば実際の移動処理は、<b>Transformコンポーネント</b>を直接変化させて、<b>衝突判定のみ使用する</b>という使い方もできます。<br />
<br />


　また、<b>Transformコンポーネントを自動更新</b>する更新補助とは別に、<b>ステートとイベント</b>という、アルゴリズム補助というか、処理の分割を補助する機能があります。<br />
　<b>ステートとイベント</b>をうまく使い分けることで、各オブジェクトの状態変化を細かく記述できます。なにより<b>ステートとイベント</b>を使うと、コードが否応なしに綺麗になります。<br />
　<b>ステートとイベント</b>は、各オブジェクトの状態や動きを細かく分割する技術なので、結果的に、ブロック単位（通常は関数単位）での記述を強いる結果になります。そのため、必然的に構造的な記述になり、可読性は増します。<br />
<br />
<h3>１０１．移動アクション</h3>
<h4>アクション系コンポーネント</h4>
　フレームワークでは、<b>アクション系コンポーネント</b>と呼ばれる、自動更新処理のコンポーネント群があります。<br />
　拡大縮小を担う<b>ScaleToおよびScaleBy</b>、回転を担う<b>RotateToおよびRotateBy</b>、そして移動を担う<b>MoveToおよびMoveBy</b>です。<br />
　これらはゲームオブジェクトの<b>コンポーネント</b>に登録することで、そのゲームオブジェクトが、指定した自動動作を行います。<br />
　<b>Sample101ディレクトリ</b>には、ここで解説するサンプルが実装されています。<br />
　リビルドをして実行すると以下のような画面が出ます。<b>XBox360コントローラ</b>をつけると、カメラ位置が変わります。
<p>&nbsp;</p>
<img src="img/1001a.jpg" width="80%"/>
<p>図1001a</p>
<p>&nbsp;</p>
<h4>MoveByコンポーネント</h4>
　ここでは、移動コンポーネントである<b>MoveBy</b>を紹介します。<b>MoveBy</b>は<b>何秒間で、どこどこの相対位置まで移動する</b>を指定するコンポーネントです。<b>相対位置</b>というのは、最初にいる位置からの相対方向です。<br />
　ソリューションエクスプローラーの<b>「ヘッダーファイル」内のCharactor.h</b>および、<b>「ソースファイル」内のCharactor.cpp</b>が、このサンプルの主な記述ファイルです。<br />
　以下は<b>のCharactor.h</b>の<b>Boxクラスの宣言</b>です。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class Box : public GameObject;
    //  用途: ボックス
    //--------------------------------------------------------------------------------------
    class Box : public GameObject{
        Vector3 m_StartPos;
        float m_Span;
    public:
        //構築と破棄
        Box(const shared_ptr&lt;Stage>& StagePtr, const Vector3& StartPos);
        virtual ~Box();
        //初期化
        virtual void Create() override;
        //更新
        virtual void Update2() override;
    };
</pre>
</div>
　ここでは、更新系仮想関数は
<div class="box1">
<pre>
        //更新
        virtual void Update2() override;
</pre>
</div>
　しか宣言されてません。<b>Update()関数</b>は、<b>アクションコンポーネントが自動処理</b>するので必要ありません。<br />
　以下は、<b>Charactor.cpp</b>の<b>Box::Create()関数</b>の抜粋です。
<div class="box1">
<pre>
    //初期化
    void Box::Create(){

        //中略

        //相対移動アクションをつける
        auto PtrMoveBy = AddComponent&lt;MoveBy>();
        PtrMoveBy->SetParams(2.0f, Vector3(m_Span, 0, 0));
        //アクション実行開始
        PtrMoveBy->Run();
    }
</pre>
</div>
　<b>AddComponent&lt;MoveBy>();</b>で、<b>MoveByコンポーネント</b>を追加できます。<br />
　追加に成功すると<b>MoveByコンポーネントのポインタ</b>が返りますので、そのメンバ関数である、<b>SetParams()関数</b>で動きを指定します。
<div class="box1">
<pre>
        PtrMoveBy->SetParams(2.0f, Vector3(m_Span, 0, 0));
</pre>
</div>
　は、<b>2秒間で、相対方向のVector3(m_Span, 0, 0)まで移動せよ</b>という設定です。<b>Run()関数</b>で実行開始できます。<br />
<br/>
<h4>MoveBy終了後の処理</h4>
　ここでは、<b>MoveBy</b>を１回だけ実行するだけなので、移動が終了すると自動的に止まってしまいます。<br />
　それでは面白くないので、行ったり来たりするようにコードを追加します。それが<b>Box::Update2()</b>に記述されています。
<div class="box1">
<pre>
    //更新
    void Box::Update2(){
        //相対移動アクションを取り出す
        auto PtrMoveBy = GetComponent&lt;MoveBy>();
        if (PtrMoveBy->IsArrived()){
            //到着していたら移動方向を逆転させて、MoveByを初期化
            m_Span *= -1.0f;
            PtrMoveBy->SetParams(2.0f, Vector3(m_Span, 0, 0));
            //アクション実行開始
            PtrMoveBy->Run();
        }
    }
</pre>
</div>
　ここでは
<div class="box1">
<pre>
        if (PtrMoveBy->IsArrived()){
</pre>
</div>
　が重要です。この関数は、アクションが終了したかどうかを返します。ここでは、m_Spanを反転させて、あらたなパラメータを設定しています。設定後、Run()関数を呼ぶことで、実行します。<br/>
<br />
<h4>オブジェクトの追加</h4>
　オブジェクトクラスは、宣言と実装を記述しただけではステージに配置されません。<br />
　配置するには<b>GameStage.h、cpp</b>で、以下のような<b>GameStage::CreateBox()関数</b>を記述し、<b>GameStage::Create()関数</b>で呼び出します。<br />
　今回の例では、インスタンスは2つ配置しています。
<div class="box1">
<pre>
    //ボックスの作成
    void GameStage::CreateBox(){
        AddGameObject&lt;Box>(Vector3(-8.0f, 0.5, 0));
        AddGameObject&lt;Box>(Vector3(0.0f, 0.5, 0));
    }
</pre>
</div>
　以下は、呼び出し部です。
<div class="box1">
<pre>
    //初期化
    void GameStage::Create(){
        try{

            //中略

            //ボックスの作成
            CreateBox();
        }
        catch (...){
            throw;
        }
    }
</pre>
</div>
　以上で実装終了です。
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="index.html">目次</a></li>
<li><a href="10_02.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
