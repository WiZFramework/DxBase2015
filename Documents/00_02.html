<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．チュートリアル</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>００２．オブジェクトの配置</h3>
<br />
<h4>オブジェクトの配置とは</h4>
　ゲームステージには<b>ゲームオブジェクト</b>というオブジェクトを配置します。プレイヤーも敵キャラも、地面も壁も、<b>ゲームオブジェクト</b>です。<br />
　DxBase2015では、<b>GameObjectクラスか、その派生クラスを作って</b>、それらのインスタンスを配置します。<br />
　以下は、この<b>チュートリアル（Tutorial002）</b>の実行画面です。<br />
<p>&nbsp;</p>
<img src="img/0002a.jpg" width="80%"/>
<p>図0002a</p>
<p>&nbsp;</p>
<br />
<h4>リソース</h4>
　最初に覚えておくことは、もう1つ<b>リソース</b>があります。DxBase2015では、テクスチャや各頂点バッファ（メッシュ）、オーディオなど、メモリに負担がかかりそうなオブジェクトは<b>リソース</b>として登録します。そうすることで、たとえば、ゲームステージからリザルト画面に移行し、再びゲームステージを呼び出したときに、メッシュの読み取りなどに時間がかかりません。<br />
　リソースはリソースごとに解除することもできますので、ゲーム中、一度しか使わないメッシュなどは、使用後すぐに破棄することもできます。<br />
<br />
<h4>リソースの登録</h4>
　ステージでは、まず<b>リソースの登録</b>を行います。<b>Tutorial002</b>のソリューションを開き、<b>GameStage.h、GameStage.cpp</b>を参照してください。<br />
　以下は、<b>GameStage.h</b>にある、<b>GameStageクラス</b>の宣言部です。
<div class="box1">
<pre>
//--------------------------------------------------------------------------------------
//  class GameStage : public Stage;
//  用途: ゲームステージクラス
//--------------------------------------------------------------------------------------
class GameStage : public Stage{
    //リソースの作成
    void CreateResourses();
    //ビューの作成
    void CreateViews();
    //プレートの作成
    void CreatePlate();
    //ボックスの作成
    void CreateBox();
public:
    //構築と破棄
    GameStage() :Stage(){}
    virtual ~GameStage(){}
    //初期化
    virtual void Create()override;
};
</pre>
</div>
　そして以下は、<b>GameStage.cpp</b>の<b>void GameStage::CreateResourses()</b>の実体です。<br />
　テクスチャをリソース化しています。
<div class="box1">
<pre>
//リソースの作成
void GameStage::CreateResourses(){
    wstring strTexture = App::GetApp()->m_wstrRelativeDataPath + L"trace.png";
    App::GetApp()->RegisterTexture(L"TRACE_TX", strTexture);
    strTexture = App::GetApp()->m_wstrRelativeDataPath + L"sky.jpg";
    App::GetApp()->RegisterTexture(L"SKY_TX", strTexture);
}
</pre>
</div>
　ここではテクスチャをリソース化しています。このサンプルで使用しているテクスチャは２つです。それぞれ、ソリューションディレクトリの<b>media</b>というディレクトリに入ってます。<br />
　ゲームで使うテクスチャやメッシュなどは、この<b>media</b>ディレクトリに入れておきます。<b>media</b>ディレクトリの中にサブディレクトリを作成して、その中に入れてもも問題はありません。<br />
　<b>App::GetApp()->m_wstrRelativeDataPath</b>というのは、この<b>media</b>ディレクトリを指します。相対パスです。<br />
　<b>App::GetApp()->m_wstrRelativeDataPath</b>は、最初に実行ファイルの同じディレクトリにある、<b>media</b>ディレクトリを探します。そして見つからなければ、実行ファイの一つ上のディレクトリにある<b>media</b>ディレクトリを探します。<br />
　プロジェクトでは、実行ファイルは、ソリューションディレクトリの<b>Debug</b>（デバッグモード）、もしくは<b>Release</b>（リリースモード）、というディレクトリに作成されます。<br />
　制作中は、リソースデータはデバッグモードでもリリースモードでも同じディレクトリを指した方が都合がいいです。そのため制作中は、<b>実行ファイの一つ上のディレクトリにあるmediaディレクトリ</b>にまとめた方が便利です。<br />
　しかし、リリース後は、<b>実行ファイと同じディレクトリにmediaディレクトリを置く</b>ほうが都合がよいです。ソースを配布するなら別ですが、通常、実行ファイルで配布されますので。<br />
　そんなわけでプログラム中では、テクスチャやゲームデータファイルにアクセスするために、<b>App::GetApp()->m_wstrRelativeDataPath</b>を使用します。<br />
　<b>App::GetApp()</b>は、このこのアプリケーションの<b>アプリケーションクラスのスタティックメンバ関数</b>です。<br />
　アプリケーションクラスは、このアプリケーション中、１つだけ存在して、アプリケーション中、共通で使う変数などを参照できます。詳しくはAppクラスのコメントを参照してください。<br/>
　リソースは<b>名前</b>をつけて登録します。そうするとその後、アプリケーションが動作している間（意図的に削除しなければ）その<b>名前</b>でアクセスできます。ここで登録しているテクスチャリソースの名前は、<b>TRACE_TXとSKY_TX</b>です。<br />
　テクスチャはここで実装している、<b>jpg、png形式</b>のほかに<b>dds、tga形式</b>に対応しています。（テクスチャ読み込みは、<b>マイクロソフト社のDirectXTX</b>に依存しています。）<br />
<br />
<h4>プレートの生成とコンポーネント</h4>
　地面になっている板を<b>プレート</b>と称しています。<br />
　<b>プレート</b>のようにゲーム中変化しないオブジェクトは、<b>GameObjectクラス</b>のインスタンスを作成することでゲームに追加できます。<br />
　それを行っているのが<b>GameStage.cpp</b>の<b>void GameStage::CreatePlate()</b>関数です。
<div class="box1">
<pre>
//プレートの作成
void GameStage::CreatePlate(){
    //ステージへのゲームオブジェクトの追加
    auto Ptr = AddGameObject&lt;GameObject>();
    //変化コンポーネント（Transform）の取得
    auto TrancePtr = Ptr->GetComponent&lt;Transform>();
    //スケーリングの設定
    TrancePtr->SetScale(200.0f, 200.0f, 1.0f);
    //回転の設定
    Quaternion Qt;
    Qt.RotationRollPitchYawFromVector(Vector3(XM_PIDIV2, 0, 0));
    TrancePtr->SetQuaternion(Qt);
    //位置の設定
    TrancePtr->SetPosition(0, 0, 0);
    //描画コンポーネントの追加
    auto DrawComp = Ptr->AddComponent&lt;SimplePNTDraw>();
    //描画コンポーネントに形状（メッシュ）を設定
    DrawComp->SetMeshResource(L"DEFAULT_SQUARE");
    //描画コンポーネントテクスチャの設定
    DrawComp->SetTextureResource(L"SKY_TX");
    //自分に影が映りこむようにする
    DrawComp->SetOwnShadowActive(true);
}
</pre>
</div>
　ステージに配置される<b>ゲームオブジェクト</b>は<b>骨組み</b>のようなものです。それ自体は何も行いませんし表示もしません。<b>ゲームオブジェクト</b>に<b>コンポーネント</b>と呼ばれる部品をセットして初めて表示したり、変化したりします。<br />
　各ゲームプログラムでは、まず、<b>ステージにゲームオブジェクトを追加</b>することで作業を開始します。<br />
　ゲームオブジェクトを追加する書式は、以下のようになります。
　それを行っているのが<b>GameStage.cpp</b>の<b>void GameStage::CreatePlate()</b>関数です。
<div class="box1">
<pre>
    //ステージへのゲームオブジェクトの追加
    auto Ptr = AddGameObject&lt;GameObject>();
</pre>
</div>
　この場合、追加するのは、<b>GameObjectクラスのインスタンス</b>です。<b>通常は</b>後で述べる<b>Boxクラス</b>のように、<b>GameObjectクラスの派生クラスを作成し、そのインスタンスをAddGameObject</b>します。<br />
　ここではプレートは何も変化しないので、<b>GameObjectクラスのインスタンス</b>として作成することが可能です。<br />
　<b>AddGameObjectテンプレート関数</b>は追加に成功すると、そのクラスのインスタンスのポインタ（shared_ptr）を返します。<br />
　各ゲームでは続いて、そこにコンポーネントを追加するなど、作業を行います。<br />
　<b>コンポーネント</b>には状態変化をつかさどるものや、衝突判定を行うもの、物理計算を行うもの、状態変化を手順化できるもの、などがあります。<br />
　コンポーネントの追加は
<div class="box1">
<pre>
    auto DrawComp = Ptr->AddComponent&lt;SimplePNTDraw>();
</pre>
</div>
　のように<br />
<b>ゲームオブジェクトのポインタ->AddComponent&lt;コンポーネントクラス名>();</b></br >
のように使用します。<br />
　コンポーネントを得るときの書式は、<br />
<b>ゲームオブジェクトのポインタ->GetComponent&lt;コンポーネントクラス名>();</b><br />
　です。<br />
　コンポーネントは、それぞれのゲームオブジェクトに対して<b>同じ型のコンポーネントは１つしか</b>追加できません。すでに存在するコンポーネントを、AddComponent()した場合、追加せずにすでに存在するポインタを返します。コンポーネントの派生クラスを使用するときは、別にAddComponent()するか、すでにあるコンポーネントを差し替えるかは選べます。<br />
　コンポーネントの中で一番重要なのは、変化をつかさどる<b>Transformコンポーネント</b>です。<br />
　<b>Transformコンポーネント</b>だけは例外で、ゲームオブジェクトが作成されたときに自動的にAddComponent()されています。ですから、上記の例のように、追加せずに
<div class="box1">
<pre>
    //変化コンポーネント（Transform）の取得
    auto TrancePtr = Ptr->GetComponent&lt;Transform>();
</pre>
</div>
　のように<b>GetComponent&lt;Transform>()</b>使用します。ほかのコンポーネントは自動的に追加されないので、各プログラムで追加します。<br />
<br/>
　<b>Transformコンポーネント</b>を介して位置や大きさを設定したら、<b>描画コンポーネント</b>を追加します。<br />
　ここでは、<b>SimplePNTDraw</b>という<b>描画コンポーネント</b>を追加します。<br />
　<b>描画コンポーネント</b>というのは、頂点シェーダーやピクセルシェーダーに直結するコンポーネントで、フレームワークでは何種類かの<b>描画コンポーネント</b>が用意されています。<br />
　<b>SimplePNTDraw</b>は単純なライティングで<b>頂点、法線、テクスチャUV</b>のフレキシブル頂点フォーマットを持つメッシュ（頂点の集合体）を描画するためのコンポーネントです。３Ｄオブジェクトを描画するコンポーネントはこのほかに<b>BasicPNTDraw</b>があります。<br />
　<b>描画コンポーネント</b>に限らず、コンポーネントは自作することができます。フレームワークに用意されている描画で不満があれば、ぜひ、どんどん自作してください。コンポーネントの自作方法はのちのサンプルで紹介します。<br />
　<b>SimplePNTDraw</b>には<b>メッシュリソースとテクスチャリソース</b>を渡します。メッシュリソースは必須ですが、テクスチャリソースはオプションです。
<div class="box1">
<pre>
    //描画コンポーネントに形状（メッシュ）を設定
    DrawComp->SetMeshResource(L"DEFAULT_SQUARE");
    //描画コンポーネントテクスチャの設定
    DrawComp->SetTextureResource(L"SKY_TX");
</pre>
</div>
　<b>SKY_TX</b>というテクスチャは、リソース登録をしたテクスチャです。<br />
　<b>DEFAULT_SQUARE</b>というのは<b>プリミティブな厚みのない板</b>です。作成時は縦1.0、横1.0で作成されていますのでそれを傾けたり大きくしたりして使用します。その設定は前述した<b>Transeformコンポーネント</b>で行っています。<br />
　<b>DEFAULT_SQUARE</b>のようなプリミティブなメッシュはほかに、以下種類があります。
<table>
<tr>
<th>識別名</th>
<th>形状</th>
</tr>
<tr>
<td>DEFAULT_SQUARE</td>
<td>各辺1.0の板</td>
</tr>
<tr>
<td>DEFAULT_CUBE</td>
<td>各辺1.0の立方体</td>
</tr>
<tr>
<td>DEFAULT_SPHERE</td>
<td>直径1.0の球</td>
</tr>
<tr>
<td>DEFAULT_CAPSULE</td>
<td>直径1.0の球を上下につけてる長さ1.0のカプセル</td>
</tr>
<tr>
<td>DEFAULT_CYLINDER</td>
<td>直径1.0で長さ1.0のシリンダー</td>
</tr>
<tr>
<td>DEFAULT_CONE</td>
<td>直径1.0で高さ1.0のコーン（円錐）</td>
</tr>
<tr>
<td>DEFAULT_TORUS</td>
<td>外径の直径1.0のドーナッツ</td>
</tr>
<tr>
<td>DEFAULT_TETRAHEDRON</td>
<td>1辺1.0の正4面体</td>
</tr>
<tr>
<td>DEFAULT_OCTAHEDRON</td>
<td>1辺1.0の正8面体</td>
</tr>
<tr>
<td>DEFAULT_DODECAHEDRON</td>
<td>1辺1.0の正12面体</td>
</tr>
<tr>
<td>DEFAULT_ICOSAHEDRON</td>
<td>1辺1.0の正20面体</td>
</tr>
</table>
　これらのメッシュは、フレームワークであらかじめ登録されているわけですが、サイズなどのパラメータを変えたい時はこれらの形状のメッシュを自作することができます。その際注意したいのは、<b>Transeformコンポーネント</b>で変形可能かどうかを確認することです。たとえば、直方体は<b>DEFAULT_CUBE</b>を拡大率を変えることで作成できます。<br />
　また、メッシュを作成したうえで一部の頂点を変更してオリジナルなメッシュを作成することもできます。また、0からメッシュを作成することもできます。<br />
　メッシュリソースはこのほかに<b>FbxMeshResource</b>があります。FBXフォーマットで作成されたモデルを表示することもできます。もちろんボーンアニメーションも再生可能です。FBXフォーマットの読み込みには、<b>Autodesk社のfbxsdk(2015.1)</b>を使用しています。<br />
<br />
　メッシュやテクスチャの設定が終わったら、最後に<b>影</b>を設定します。
<div class="box1">
<pre>
    //自分に影が映りこむようにする
    DrawComp->SetOwnShadowActive(true);
</pre>
</div>
　これは<b>他者の影を映るようにする</b>という設定です。<b>影</b>には、影を出す側と、映り込む側があります。片方、もしくは両方尾指定できます。影を出す側の設定は、次のBoxの解説で述べます。プレートは自分の影は出さずに、影を受けるだけの設定です。（プレートにも影を出す設定を実装可能ですが、自己影が大きく映り込むのでおすすめできません）。<br />
<br />
<h4>Boxの登録</h4>
　このサンプルにはボックス状のものが1個だけ表示されます。<br />
　ゲームステージ（GameStage.cpp）ではボックスを配置するのに、以下のように記述しています。
<div class="box1">
<pre>
    //ボックスの作成
    void GameStage::CreateBox(){
        AddGameObject&lt;Box>(Vector3(0.0f,0.5f,0.0f));
    }
</pre>
</div>
　これは、<b>Boxクラスのインスタンスを作成して配置せよ</b>という意味です。<br />
　<b>Boxクラス</b>は<b>Character.hとCharacter.cpp</b>に記載があります。<br />
　以下は<b>Character.hのBoxの宣言部</b>です
<div class="box1">
<pre>
//--------------------------------------------------------------------------------------
//  class Box : public GameObject;
//  用途: ボックス
//--------------------------------------------------------------------------------------
class Box : public GameObject{
    Vector3 m_StartPos;
public:
    //構築と破棄
    Box(const shared_ptr&lt;Stage>& StagePtr, const Vector3& StartPos);
    virtual ~Box();
    //初期化
    virtual void Create() override;
};
</pre>
</div>
　ご覧のように、<b>BoxクラスはGameObjectの派生クラス</b>として作成します。そしてデフォルトコンストラクタは作成せずに、かならず<span class="red"><b>第1引数が、const shared_ptr&lt;Stage>& StagePtr</b></span>となるように、コンストラクタを宣言します。これは<b>フレームワークの仕様で、大変重要な部分</b>です。<br />
　第2引数以降は、自由に宣言して構いません（可変長です）。重要なことは<span class="red"><b>第1引数が、const shared_ptr&lt;Stage>& StagePtr</b></span>となること、です。<br />
　そしてデストラクタも宣言しています。<br />
　このほかに
<div class="box1">
<pre>
    //初期化
    virtual void Create() override;
</pre>
</div>
　を多重定義します。<b>Create()仮想関数</b>は、このインスタンスがステージに追加されたときに自動的に呼ばれます。コンポーネントの登録などはこの関数で行います。<br/>
<br />
　<b>Character.cpp</b>では、コンストラクタ、デストラクタ、そして<b>Create()仮想関数</b>を記述します。<br />
　コンストラクタでは、メンバイニシャライザで、第2引数の値（Boxの位置、Vector3型）を設定します。<br />
　フレームワークでは<b>Vector3型</b>のほかに、<b>Vector2、Matrix4X4、Quaternion型</b>などを持っていて、ライブラリ内の<b>MathVector.hなどMathで始まるヘッダ</b>で定義されています。主にDirectXMathで使用する、XMVECTORなどのラッピングクラス、関数群です。XMVECTORは、SSE2をサポートする最適化された機能ですが、使用するのにロード関数やストア関数を駆使しなければならず、荷が重いです。そのためラッピング関数群を用意しています。こうすることで、XMVECTORを意識することなくVectorやMatrixを扱えるようになっています。<br />
<br />
　以下は<b>Create()仮想関数の実体</b>です。
<div class="box1">
<pre>
//初期化
void Box::Create(){
    auto PtrTransform = GetComponent&lt;Transform>();
    PtrTransform->SetScale(1.0f, 1.0f, 1.0f);
    PtrTransform->SetRotation(0.0f, 0.0f, 0.0f);
    PtrTransform->SetPosition(m_StartPos);
    //影をつける
    auto ShadowPtr = AddComponent&lt;Shadowmap>();
    ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");
    //描画コンポーネント
    auto PtrDraw = AddComponent&lt;BasicPNTDraw>();
    PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
    PtrDraw->SetTextureResource(L"TRACE_TX");
    //透過処理
    SetAlphaActive(true);
}
</pre>
</div>
　ここではプレートのところで説明したように、<b>コンポーネントの設定</b>を行ってます。<br />
　まず、<b>Transform</b>を<b>Get</b>して、スケーリング、回転、位置（コンストラクタのパラメータで渡される）を設定します。<br />
　その後
<div class="box1">
<pre>
    //影をつける
    auto ShadowPtr = AddComponent&lt;Shadowmap>();
    ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");
</pre>
</div>
　のように影をつけます。こちらはプレートと違い、<b>影を出す方</b>です。<b>Shadowmap</b>というのはいわゆる<b>シャドウマップ</b>です。ライトを視点にしたオブジェクトの見え方を特殊なバッファ（ステンシルバッファ）に書き込み、実際のオブジェクトの描画で合わせて表示する仕組みです。<br />
　シャドウマップと合わせて表示するかどうかの設定が、プレートのところで説明した<b>SetOwnShadowActive()</b>です。<br/>
　影の出し方はいろいろありますが、フレームワークでは、<b>シンプルで、ゲームに負担をかけない</b>をモットーにしています。そのため、複数のライトは使用できますが、影を作り出すのはビューの先頭のライトです。ですから、影の向きをかえたければ、ビューの0番目のライトの向きを変更してください。<br/>
　影は形状を指定できます。通常は、表示するメッシュと同じものを使用しますが、たとえば丸影にしたければ<div class="box1">
<pre>
    ShadowPtr->SetMeshResource(L"DEFAULT_TORUS");
</pre>
</div>
　のようにすればドーナッツ影になります（かなり違和感がありますが・・・）<br/>
<br/>
　最後に透過処理です。ここで使用している<b>TRACE_TX</b>は透明色も含みます。そのため、透過処理が必要です。
<div class="box1">
<pre>
    //透過処理
    SetAlphaActive(true);
</pre>
</div>
　このように、透過処理はGameObjectの派生クラス（ここではBoxクラス）のメンバ関数で指定します。<br/>
　半透明処理も可能ですが、サンプルで紹介します。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_01.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_03.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
