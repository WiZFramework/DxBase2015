<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>１．更新補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>１０２．アクションを統合する</h3>
<h4>連続したアクション</h4>
　前項では、唯一のアクションの実装を行いました。<br />
　しかし、AI操作などで、連続した動きを登録できると便利です。<b>Actionコンポーネント</b>はこうした連続したアクションを登録できるコンポーネントです。<br />
　サンプル102を実行すると以下のように３つの球が連続した動作を繰り返します。
<p>&nbsp;</p>
<img src="img/1002a.jpg" width="80%"/>
<p>図1002a</p>
<p>&nbsp;</p>
　このサンプルは、<b>回転と移動</b>の連続動作を登録しています。<br />
　<b>Actionコンポーネント</b>は、<b>拡大縮小、回転、移動</b>のラインを別々に持ってます。そのため、<b>回転しながら移動</b>とか<b>縮小しながら回転</b>などの定義が可能です。<br />
<br />
　ではソースを見てみましょう。<b>Charactor.hとCharactor.cpp</b>に記述があります。まず、ヘッダです。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class ActionObject : public GameObject;
    //  用途: アクションする配置オブジェクト
    //--------------------------------------------------------------------------------------
    class ActionObject : public GameObject{
        Vector3 m_StartPos;
    public:
        //構築と破棄
        ActionObject(const shared_ptr&lt;Stage>& StagePtr, const Vector3& StartPos);
        virtual ~ActionObject();
        //初期化
        virtual void Create() override;
    };
</pre>
</div>
　宣言はいたってシンプルです。<b>Actionコンポーネント</b>のみ実装する場合、<b>Update()関数もUpdate2()関数も</b>必要ではありません（ただこれはサンプルだから可能であり、一般的には相互作用を行うので、Update系関数は必要になるでしょう）。<br />
<br/>
<h4>連続したアクションを定義する</h4>
　<b>Actionコンポーネント</b>を定義するには、<b>Charactor.cpp</b>で<b>ActionObject::Create()関数</b>に記述します。以下が、その主要な部分です。
<div class="box1">
<pre>
    //初期化
    void ActionObject::Create(){

        //中略

        //アクションの登録
        auto PtrAction = AddComponent&lt;Action>();
        PtrAction->AddRotateBy(1.0f, Vector3(0, XM_PI, 0));
        PtrAction->AddMoveBy(1.0f, Vector3(2.0f, 0, 0));
        PtrAction->AddMoveBy(0.5f, Vector3(0, 1.0f, -1.0f), 
            Lerp::Linear, Lerp::EaseOut, Lerp::Linear);
        PtrAction->AddMoveBy(0.5f, Vector3(0, -1.0f, -1.0f), 
            Lerp::Linear, Lerp::Easein, Lerp::Linear);
        PtrAction->AddMoveBy(2.0f, Vector3(-4.0f, 0, 0));
        PtrAction->AddMoveBy(1.0f, Vector3(0, 0, 2.0f));
        PtrAction->AddMoveBy(1.0f, Vector3(2.0f, 0, 0));
        //ループする
        PtrAction->SetLooped(true);
        //アクション開始
        PtrAction->Run();

        //中略
    }
</pre>
</div>
　ここでポイントは各ライン（拡大縮小、回転、移動）は別々に働くということです。たとえば回転は
<div class="box1">
<pre>
        PtrAction->AddRotateBy(1.0f, Vector3(0, XM_PI, 0));
</pre>
</div>
　と1行記載されてるだけですが、これで、<b>1秒で半回転</b>をループします。移動は全体で6秒の処理ですが、全体でループします。<br />
　もし、回転を<b>1秒で半回転</b>だけ行って、あとは、移動処理時間に合わせるために<b>5秒間何もしない</b>処理を実装する場合、
<div class="box1">
<pre>
        PtrAction->AddRotateInterval(5.0f);
</pre>
</div>
　のように記述します。<b>5秒間何も（回転）しない</b>という意味です。インターバル関数は、拡大縮小や移動にも、それぞれあります。<br />
<br />
　また、移動の一部に使用している
<div class="box1">
<pre>
        PtrAction->AddMoveBy(0.5f, Vector3(0, 1.0f, -1.0f), 
            Lerp::Linear, Lerp::EaseOut, Lerp::Linear);
        PtrAction->AddMoveBy(0.5f, Vector3(0, -1.0f, -1.0f), 
            Lerp::Linear, Lerp::Easein, Lerp::Linear);
</pre>
</div>
　は、<b>補間処理を指定</b>しています。<b>Lerp::EaseOutはだんだん遅くなる</b>で<b>Lerp::Easeinはだんだん速くなる</b>です。このようにして疑似ジャンプを表現しています。補間処理はこのほかに、3次関数とコサインがあります。ただし、補間を指定できるのは、移動処理だけで、回転や拡大縮小は線形補間のみとなります。<br />
<br/>
　ActionObjectクラスの記述が終わったら、いつものように、<b>GameObjectクラスでインスタンスを実装</b>します。記述方法は、前項までを参考にしてください。<br />
　また、以降のドキュメントでは、GameObjectクラスでのインスタンス作成処理は、特別のことがない限り解説しませんので注意してください。
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="10_01.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="10_03.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
