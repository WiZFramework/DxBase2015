<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>シンプルDxBase2015</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>Simple07．独自フォーマットのスキンメッシュデータの読み込み</h3>
<br />
<h4>Fbx2Binツールで作成したスキンメッシュデータを読み込む</h4>
　<b>DxBase2015Simple/Simple07</b>のソリューションを開いて、リビルド、実行しますと以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/Simple07a.jpg" width="80%"/>
<p>図Simple07a</p>
<p>&nbsp;</p>
<h4>スキンメッシュの仕組み</h4>
　<b>スキンメッシュ</b>は<b>言葉は知ってるが、仕組みはちょっと</b>という人も多いと思います。ですが、よく考えると、実にうまくできた仕組みであることがわかります。<br />
　簡単に説明しますと、人でも犬や猫でも、<b>骨格</b>を持っています。それで、その骨格を覆い尽くすように、肉や皮膚がその周りを覆ってます。<b>スキンメッシュ</b>の<b>スキン</b>は<b>皮膚</b>という意味です。つまり、骨格を覆う皮膚のように弾力性を持って変化するアニメーション、という意味です。<br />
　これを、コンピュータ上で表現するには、まず、<b>骨格</b>が必要になります。動物の例を考えればわかるように、骨格は腰骨から始まって、上に向かって背骨、下に向かって脚が伸びます。そしてその先には、関節をはさみながら、頭や腕、手、足などにつながります。<br />
　これをコンピュータでは<b>ボーン（骨）またはジョイント（関節）</b>といいます、このドキュメントでは<b>ボーン</b>と呼びます。<br />
　<b>ボーン</b>は<b>ルートボーン</b>を起点として、３Ｄ空間のあらゆる方向に伸びています。これはら<b>行列</b>であらわされます。すなわち、親ボーンに対する姿勢行列です。<br />
　このように親子関係をツリー構造的に表現します。そうすると親ボーンが動いたときに子ボーンもそれにつられて動き、さらに関節で親ボーンにつながりながら独自の姿勢をとることができます。<br />
<br />
　さて、ボーンが出来たら、それを覆う<b>スキン（皮膚）</b>ということになります。<br />
　ボーンに合わせて頂点をそのまま動くようにすると、当たり前ですが、硬い感じになります。実際には皮膚は<b>伸び縮み</b>するはずです。その<b>伸び縮み</b>を表現するために<b>ウェイト</b>という考え方を導入します。<b>ウェイト</b>はその頂点が影響を受けるボーンのリストです。通常は、４つまでのボーンの影響を受けるように構成します。それで、そのウェイトの足した結果を1.0になるようにします。<br />
　つまり頂点の一つ一つが影響を受けるボーンのリストを持っていて、たとえば、すべて0.25のウエイトなら均等に影響を受けるようになります。しかし、関節に近い部分の頂点は、その近い関節の影響を一番受けます。<br />
　そのようにして、ボーンが動いたときに、各頂点がボーンに引っ張られるようにウエイトに合わせて動くようにすると、スムーズなスキンメッシュが出来上がります。<br />
<br/>
　非常にざっくりした説明ですが、スキンメッシュを表現するのに必要なデータはどんなものが必要なのかがわかったと思います。<br />
　まず、ボーン情報です。そして、各頂点が、どのボーンに影響を受けて、どのようなウエイトになるかです。そして、アニメーション（瞬間瞬間のボーンごとの行列）です。しかし、<b>Fbx2Bin</b>ツールでは、ボーン単位の変換行列はデータ化しますが、ボーンそのものはデータ化しません。つまり、親子関係をたどって、ルートボーンからの相対行列から、最終的な姿勢行列にしたものをデータ化しています。<br />
　そのため、アニメーションデータは、サンプル単位の、ボーンの行列の配列となっています。あとは、各頂点のウェイトに合わせた行列の調整です。それは頂点データにあらかじめ入っています。<br />
<br/>
<h4>補間処理</h4>
　サンプリングされたデータは、0.02秒ごとにサンプリングされています。しかし、ゲームは必ずしもこの単位で更新時間が来るとは限りません。そのため、補間処理が必要になります。それも行列間の補間処理です。<br />
　このサンプルでは単純な線形補間をとっています。すなわち、行列を、いったんスケーリング、回転、移動に分割し、それ同士を補完します。そして補間結果を行列に再計算しています。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="Simple_06.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="Simple_08.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
