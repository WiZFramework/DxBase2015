<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trからのぷろansitional//EN">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2015ドキュメント(2015年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>４．独自の頂点と独自描画</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>４１０．インスタンス描画</h3>
<br />
<h4>同じオブジェクトを大量に描画する</h4>
　同じオブジェクトを大量に描画するケースは、よくあります。<br />
　たとえば、<b>木を使って森を作る</b>場合などです。その森が単なる背景のようなものであれば、ある程度まとめた形でオブジェクト化できるのですが、1本1本の木が、例えばプレイヤーに剣により倒されたりする場合、1本ずつ分離した形で描画する必要があります。<br />
　しかし、ライブラリでは、１つのGameObjectを描画するために、様々な準備を内部で行います。それは、そのオブジェクトの前に何が描画されていても、お互いが影響を与えないようにアクセラレータを初期化しているためです。<br />
　この操作が、積もり積もってゲームの動作速度に影響を及ぼします。もちろん、独自のシェーダを実装することにより、おなじクラスの複数のオブジェクトの描画を１回の描画準備で行うことは可能です。しかし、そのような独自シェーダを作成するのであれば、もっと良い方法があります。<br />
　<b>Sample410</b>を<b>リリースモードでビルド</b>し、実行してみましょう。<br />
　目の前に大量のボックスが現れます。そして、プレイヤーを動かして、そのボックスぼ塊に突っ込んでいってみましょう。<br />
　以下の画面のように、１つ１つのボックスが飛び散るような表現になり、プレイヤーはボックスを破壊しながら進んでいくような印象になります。
<p>&nbsp;</p>
<img src="img/4010a.jpg" width="80%"/>
<p>図4010a</p>
<p>&nbsp;</p>
　そして、その動作スピードは、実行環境にもよりますが、一般的なWindows8.1動作要件を満たすハードウェアであれば、ほぼ60FPSを維持したまま動作するのがわかります。<br />
<br />
<h4>インスタンス描画</h4>
　この描画手法を<b>インスタンス描画</b>といいます。（インスタンスレンダリングという場合もあります）<br />
　ここで紹介しているのは、<b>頂点シェーダ入力用のパイプラインに、複数のオブジェクトごとの行列も加える</b>というものです。<br />
　一般的な描画関数である、<b>ID3D11DeviceContext::DrawIndexed()関数</b>では、オブジェクトのワールド行列はコンスタントバッファに設定し、シェーダでその値を読みだします。しかし、その方法ですと1つのオブジェクトのワールド行列しか頂点シェーダに渡せません。<br />
　たとえ複数の行列を配列化して渡したとしても、頂点シェーダが現在処理している頂点が、どのオブジェクトのものかわからないため意味がありません。<br />
　そのため<b>DirectX11</b>では<b>ID3D11DeviceContext::DrawIndexedInstanced()関数</b>という描画関数で、頂点シェーダに<b>現在処理をしているオブジェクトのインスタンス</b>を知らせる機能を実現しています。<br />
　この関数による描画が、<b>インスタンス描画</b>というものです。<br />
<br/>
<h4>インスタンス描画の準備</h4>
　<b>インスタンス描画</b>で、<b>各インスタンスごとのワールド行列</b>は、コンスタントバッファに入れることも可能ですが、通常は<b>頂点シェーダ入力用のパイプライン</b>に入力します。<br />

　そのためには準備段階として、<b>インスタンス描画用の頂点レイアウトの定義</b>が必要になります。<br />
　サンプルでは、<b>Character.h</b>に<b>頂点レイアウトの定義</b>が記述されています。<br />
<div class="box1">
<pre>
//--------------------------------------------------------------------------------------
//const D3D11_INPUT_ELEMENT_DESC VertexPositionNormalTextureMatrixLayout[];
//用途: 位置と法線とテクスチャと行列を持つ入力レイアウトの定義
//--------------------------------------------------------------------------------------
const D3D11_INPUT_ELEMENT_DESC VertexPositionNormalTextureMatrixLayout[] =
{
    { "SV_Position", 0, DXGI_FORMAT_R32G32B32_FLOAT, 
        0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 
        0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 
        0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { "MATRIX", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 
        1, 0, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
    { "MATRIX", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 
        1, 16, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
    { "MATRIX", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 
        1, 32, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
    { "MATRIX", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 
        1, 48, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
};

//--------------------------------------------------------------------------------------
// struct VertexPositionNormalTextureMatrix;
//用途: 位置と法線とテクスチャと行列を持つ頂点の定義
//--------------------------------------------------------------------------------------
struct  VertexPositionNormalTextureMatrix
{
    VertexPositionNormalTextureMatrix()
    { }

    VertexPositionNormalTextureMatrix(XMFLOAT3 const& position, 
        XMFLOAT3 const& normal, XMFLOAT2 const& textureCoordinate,
        XMFLOAT4X4 const& matrix)
        : position(position),
        normal(normal),
        textureCoordinate(textureCoordinate),
        matrix(matrix)
    { }

    VertexPositionNormalTextureMatrix(FXMVECTOR position, 
        FXMVECTOR normal, FXMVECTOR textureCoordinate,
        FXMMATRIX const& matrix)
    {
        XMStoreFloat3(&this->position, position);
        XMStoreFloat3(&this->normal, normal);
        XMStoreFloat2(&this->textureCoordinate, textureCoordinate);
        XMStoreFloat4x4(&this->matrix, matrix);
    }

    XMFLOAT3 position;
    XMFLOAT3 normal;
    XMFLOAT2 textureCoordinate;
    XMFLOAT4X4 matrix;

    static const D3D11_INPUT_ELEMENT_DESC* GetVertexElement(){
        return VertexPositionNormalTextureMatrixLayout;
    }
    static UINT GetNumElements(){
        return  ARRAYSIZE(VertexPositionNormalTextureMatrixLayout);
    }
};
</pre>
</div>
　ここでは、<b>VertexPositionNormalTextureMatrixLayout</b>という頂点レイアウトの定義と、<b>VertexPositionNormalTextureMatrix</b>という頂点フォーマットを定義しています。<br />
　<b>頂点位置、法線、テクスチャ、行列</b>のフォーマットです。これは、通常の３Ｄ描画用のフォーマットに<b>行列</b>要素を加えたものになります。<br />
<br />
<h4>シェーダの作成</h4>
　このサンプルで使用するシェーダは<b>頂点シェーダとピクセルシェーダ</b>です。まず共通にインクルードするヘッダを記述します。<b>InstanceInc.hlsli</b>です。<br />
<div class="box1">
<pre>
cbuffer SimpleConstantBuffer : register(b0)
{
    float4x4 View   : packoffset(c0);
    float4x4 Projection : packoffset(c4);
    float4 LightDir : packoffset(c8);
    float4 Param : packoffset(c9);
    float4 LPos : packoffset(c10);
    float4 EyePos   : packoffset(c11);
    float4x4 LView  : packoffset(c12);
    float4x4 LProjection    : packoffset(c16);
};

struct VertexShaderInput
{
    float4 pos : SV_Position;
    float3 norm : NORMAL;
    float2 tex : TEXCOORD0;
    <span class="red">float4x4 mat : MATRIX;  // インスタンスごとに設定される行列</span>
    uint InstanceId : SV_InstanceID;  // インスタンスＩＤ
};

struct PixelShaderInput
{
    float4 pos : SV_POSITION;
    float3 norm : NORMAL;
    float3 lRay     : NORMAL1;
    float3 View : NORMAL2;
    float2 tex : TEXCOORD0;
    float4 posLWVP  : POSITION1;
    float4 lightSpacePos : POSITION2;
};
</pre>
</div>
　上記のように、通常はコンスタントバッファに設定されるワールド行列が、<b>SimpleConstantBuffer構造体</b>には存在しません。その代り、頂点シェーダへの入力の、<b>VertexShaderInput構造体</b>には、<b>float4x4 mat : MATRIX;</b>があります。これは、先に定義した入力レイアウトと同じ並びです。<br />
<br />
　続いて頂点シェーダですが、<b>VSInstance.hlsl</b>に記述します。
<div class="box1">
<pre>
#include "InstanceInc.hlsli"

PixelShaderInput main(VertexShaderInput input)
{
    //ピクセルシェーダーに渡す変数
    PixelShaderInput vertexShaderOutput;
    //頂点の位置を変換
    float4 pos = float4(input.pos.xyz, 1.0f);
    //ワールド変換
    <span class="red">pos = mul(pos, input.mat);</span>
    //ビュー変換
    pos = mul(pos, View);
    //射影変換
    pos = mul(pos, Projection);
    //ピクセルシェーダに渡す変数に設定
    vertexShaderOutput.pos = pos;
    //テクスチャのUV値を設定
    vertexShaderOutput.tex = input.tex;
    //ライティング用に法線をワールド変換して設定
    <span class="red">vertexShaderOutput.norm = mul(input.norm, (float3x3)input.mat);</span>
    //影用の値を計算
    float4 modelPos = float4(input.pos.xyz, 1.0f);
    <span class="red">modelPos = mul(modelPos, input.mat);</span>
    float4 lightSpacePos = mul(modelPos, LView);
    lightSpacePos = mul(lightSpacePos, LProjection);
    vertexShaderOutput.lightSpacePos = lightSpacePos;
    // Light ray
    float3 lRay = LPos.xyz - modelPos.xyz;
    vertexShaderOutput.lRay = lRay;
    vertexShaderOutput.View = EyePos.xyz - modelPos.xyz;

    <span class="red">float4x4 LightWorldViewProj = input.mat;</span>
    LightWorldViewProj = mul(LightWorldViewProj, LView);
    LightWorldViewProj = mul(LightWorldViewProj, LProjection);
    vertexShaderOutput.posLWVP = mul(input.pos, LightWorldViewProj);

    //ピクセルシェーダに出力
    //returnはピクセルシェーダに渡すことを意味する
    return vertexShaderOutput;
}
</pre>
</div>
　赤くなっているところが、ワールド行列を参照しているコードです。通常はコンスタントバッファから渡される行列を使用しますが、頂点シェーダの入力に渡されたワールド行列を使用して変換しています。ビュー行列と射影行列はカメラの行列ですから、コンスタントバッファの値を使用します。<br />
　ここでは影の映り込みの処理も行いますので、影用の計算も行っています。本体同様、頂点シェーダの入力のワールド行列を使用します。<br />
<br />
　続いてピクセルシェーダですが、こちらは、通常のピクセルシェーダと変わりません。ライト法線と影とテクスチャを使って、デバイス座標上のピクセルの色を決定します。<b>PSInstance.hlsl</b>です。
<div class="box1">
<pre>
#include "InstanceInc.hlsli"

Texture2D&lt;float4> SimpleTexture : register(t0);
// 深度マップ
Texture2D g_DepthMap : register(t1);

SamplerState SimpleSampler : register(s0);
SamplerState g_SamplerDepthMap : register(s1);


float4 main(PixelShaderInput input) : SV_TARGET
{
    //影があるかないかを決定
    float3 shadowColor = float3(1.0f, 1.0f, 1.0f);
    // テクセルを計算
    float2 texel = 
        float2(
            input.posLWVP.x / input.posLWVP.w * 0.5f + 0.5f, 
            input.posLWVP.y / input.posLWVP.w * -0.5f + 0.5f
        );
    float depth = input.posLWVP.z / input.posLWVP.w - 0.00005f;
    float sm = g_DepthMap.Sample(g_SamplerDepthMap, texel).x;
    if (texel.x >= 0 && texel.x &lt;= 1 && texel.y >= 0 && texel.y &lt;= 1){
        // 現在の深度値と深度マップ上の深度値を比較
        if (sm &lt; depth){
            //影は70%の明度
            shadowColor.xyz = 0.7f;
        }
        else{
            shadowColor.xyz = 1.0f;
        }
    }
    float3 lightdir = normalize(LightDir.xyz);
    float3 N1 = normalize(input.norm);
    //最終色の決定
    //まずライティングの影響
    float4 RetColor = saturate(dot(N1, -lightdir) + float4(0.7, 0.7, 0.7, 1.0));
    //ライトの透明処理はなし
    RetColor.a = 1;
    //テクスチャと合わせる
    RetColor = SimpleTexture.Sample(SimpleSampler, input.tex) * RetColor;
    //影と合わせる
    RetColor.rgb = RetColor.rgb * shadowColor;
    //決定色リターン
    return RetColor;
}
</pre>
</div>
　続いてシャドウマップ用の頂点シェーダです。シャドウマップも、インスタンス描画に対応しなければいけないので、作成します。<b>VSInstanceShadowmap.hlsl</b>です。シャドウマップは頂点シェーダしかないので、インクルード用のファイルは用意しません。
<div class="box1">
<pre>
cbuffer CustomShadowmapConstantBuffer : register(b0)
{
    float4x4 View               : packoffset(c0);
    float4x4 Projection             : packoffset(c4);
};

struct VertexShaderInput
{
    float4 pos : SV_Position;
    float3 norm : NORMAL;
    float2 tex : TEXCOORD0;
    <span class="red">float4x4 mat : MATRIX; // インスタンスごとに設定される行列</span>
    uint InstanceId           : SV_InstanceID;   // インスタンスＩＤ
};


float4 main(VertexShaderInput input) : SV_POSITION
{
    float4 Output;
    input.pos.w = 1.0f;
    <span class="red">Output = mul(input.pos, input.mat);</span>
    Output = mul(Output, View);
    Output = mul(Output, Projection);
    return Output;
}
</pre>
</div>
　赤くなっているところが、頂点シェーダ入力から行列を取り出すところです。こちらも、通常はコンスタントバッファから得るワールド行列を、頂点シェーダの入力から得ます。<br />
　シャドウマップの戻り値は<b>float4</b>です。このまま、ピクセルシェーダはスルーして描画します。<br />
<br />
<h4>シェーダクラスの作成</h4>
　シェーダを作成したので、シェーダークラスを作成します。同じシェーダを使いまわすので、シングルトン用のシェーダクラスを作成します。<br />
　<b>Character.h、cpp</b>にあります。まずはヘッダです。
<div class="box1">
<pre>
    //インスタンスシャドウマップ用コンスタントバッファ構造体
    struct InstanceShadowmapConstantBuffer
    {
        XMMATRIX mView;
        XMMATRIX mProj;
        InstanceShadowmapConstantBuffer() {
            memset(this, 0, sizeof(InstanceShadowmapConstantBuffer));
        };
    };
    //--------------------------------------------------------------------------------------
    //  class CBInstanceShadowmap : 
    //      public ConstantBuffer&lt;CBInstanceShadowmap,InstanceShadowmapConstantBuffer>;
    //  用途: インスタンスシャドウマップコンスタントバッファ
    //--------------------------------------------------------------------------------------
    class CBInstanceShadowmap : 
        public ConstantBuffer&lt;CBInstanceShadowmap, InstanceShadowmapConstantBuffer>{
    public:
    };

    //--------------------------------------------------------------------------------------
    //  class VSInstanceShadowmap : 
    //      public VertexShader&lt;VSInstanceShadowmap, VertexPositionNormalTextureMatrix>;
    //  用途: VSInstanceShadowmap頂点シェーダ
    //--------------------------------------------------------------------------------------
    class VSInstanceShadowmap : 
        public VertexShader&lt;VSInstanceShadowmap, VertexPositionNormalTextureMatrix>{
    public:
        //構築
        VSInstanceShadowmap();
    };

    //--------------------------------------------------------------------------------------
    //  struct InstanceConstantBuffer;
    //  用途: 入力バッファのCPU側構造体
    //--------------------------------------------------------------------------------------
    struct InstanceConstantBuffer
    {
        Matrix4X4 View;
        Matrix4X4 Projection;
        Vector4 LightDir;
        Vector4 Param;  //汎用パラメータ
        Vector4 LPos;
        Vector4 EyePos;
        Matrix4X4 LView;
        Matrix4X4 LProjection;
        InstanceConstantBuffer() {
            memset(this, 0, sizeof(InstanceConstantBuffer));
        };
    };

    //シェーダ宣言
    //コンスタントバッファ
    class CBInstance : public ConstantBuffer &lt; CBInstance, InstanceConstantBuffer>{
    public: 
    };
    //頂点シェーダ
    class VSInstance : public VertexShader&lt;VSInstance, VertexPositionNormalTextureMatrix> {
    public: 
        VSInstance();
    };
    //ピクセルシェーダ
    class PSInstance : public PixelShader&lt;PSInstance>
    {
    public:
        PSInstance();
    };

</pre>
</div>
　このように、シェーダクラスは、クラスとコンストラクタを記述するといったシンプルなものです。<br />
　cppファイル<b>Character.cpp</b>の実装は以下のようになります。
<div class="box1">
<pre>
    //シャドウマップシェーダー実体
    //シャドウマップコンスタントバッファシングルトン処理
    unique_ptr&lt;CBInstanceShadowmap, CBInstanceShadowmap::Deleter> CBInstanceShadowmap::m_Ptr;
    //シャドウマップ頂点シェーダシングルトン処理
    unique_ptr&lt; VSInstanceShadowmap, VSInstanceShadowmap::Deleter>  VSInstanceShadowmap::m_Ptr;
    //頂点シェーダ実体
    VSInstanceShadowmap::VSInstanceShadowmap() :
        VertexShader(App::GetApp()->m_wstrRelativeShadersPath + L"VSInstanceShadowmap.cso")
    {}

    //描画用シェーダー実体
    //コンスタントバッファシングルトン処理
    unique_ptr&lt;CBInstance, CBInstance::Deleter> CBInstance::m_Ptr;
    //頂点シェーダシングルトン処理
    unique_ptr&lt;VSInstance, VSInstance::Deleter> VSInstance::m_Ptr;
    //頂点シェーダ実体
    VSInstance::VSInstance() : 
        VertexShader(App::GetApp()->m_wstrRelativeShadersPath + L"VSInstance.cso")
    {}
    //ピクセルシェーダシングルトン処理
    unique_ptr&lt;PSInstance, PSInstance::Deleter> PSInstance::m_Ptr;
    //ピクセルシェーダ実体
    PSInstance::PSInstance() :
        PixelShader(App::GetApp()->m_wstrRelativeShadersPath + L"PSInstance.cso")
    {}
</pre>
</div>
<br/>
<h4>配置オブジェクトの作成</h4>
　このサンプルの設計では、配置オブジェクトはUpdate処理はそれぞれ行い、描画のみマネージャ的なクラスに任せます。こうすることでそれぞれのオブジェクトの変化にはそれぞれで対応しやすくなります。<br />
　まず、個別の配置オブジェクトである、<b>FixedBox</b>の作成から始めますが、その前に、<b>FixedBox</b>がばらばらになった状態の1つ1つのデータを管理する<b> SplitBoxData構造体</b>を定義します。<br />
　この構造体は、拡大率、回転、位置のほか、速度や回転速度といった、ばらばらのオブジェクトの行列を作成するのに必要な情報をまとめます。また、<b>UpdateData()メンバ関数</b>を利用して状態変化を実装します。<br />
　そうしておいて、<b>FixedBox</b>を作成します。<br />
　<b>FixedBox</b>には、<b> SplitBoxData構造体</b>の配列もメンバにしておきます。ステートマシンも実装します。<b> SplitBoxData構造体</b>配列は、初期状態では空です。プレイヤーが一定の距離より近づいたときに、ステートが変化し、バラバラ状態になります。<br />
<br />
<h4>マネージャによる描画</h4>
　<b>FixedBox</b>は描画は行いません。そのかわりに、<b>Update3()関数</b>により通常状態の場合は立方体の行列を、バラバラの時は<b> SplitBoxData構造体</b>の配列のそれぞれの行列を、描画マネージャクラスである<b>DrawBoxManagerクラス</b>に渡します。<br />
　<b>DrawBoxManagerクラス</b>は、<b>Matrix4X4（行列）</b>の配列<b>m_InstanceVec</b>を持ちます。また、行列の配列を保持する<b>頂点バッファ、m_MatrixBuffer</b>を構築します。このバッファは<b>Update3()メンバ関数</b>で、<b>現在のm_InstanceVec</b>によって、更新されます。<br /><b>頂点バッファ、m_MatrixBuffer</b>は、そのまま頂点シェーダに渡される配列です。<br/>
　<b>DrawBoxManagerクラス</b>のゲームオブジェクトは２つ用意します。通常状態のオブジェクトの描画と、バラバラ状態のオブジェクトの描画用です。<br />
　<b>DrawBoxManagerクラス</b>の根幹は、<b>Draw()関数</b>です。この関数で<b>インスタンス描画</b>を実装します。
<div class="box1">
<pre>
void DrawBoxManager::Draw(){
    //デバイスの取得
    auto Dev = App::GetApp()->GetDeviceResources();
    auto pDx11Device = Dev->GetD3DDevice();
    auto pID3D11DeviceContext = Dev->GetD3DDeviceContext();
    //ステータスのポインタ
    auto RenderStatePtr = GetStage()->GetRenderState();

    //シャドウマップのレンダラーターゲット
    auto ShadoumapPtr = GetStage()->GetShadowMapRenderTarget();

    auto PtrT = GetComponent&lt;Transform>();
    //ステージからカメラを取り出す
    auto PtrCamera = GetStage()->GetTargetCamera();
    //カメラの取得
    Matrix4X4 View, Proj, WorldViewProj;
    View = PtrCamera->GetViewMatrix();
    Proj = PtrCamera->GetProjMatrix();

    //描画するメッシュリソースを取得
    auto MeshRes = App::GetApp()->GetResource&lt;MeshResource>(m_MeshKey);

    //コンスタントバッファの設定
    InstanceConstantBuffer cb1;
    ZeroMemory(&cb1, sizeof(cb1));
    cb1.View = Matrix4X4EX::Transpose(View);
    cb1.Projection = Matrix4X4EX::Transpose(Proj);
    //ライトの設定
    //ステージから0番目のライトを取り出す
    auto PtrLight = GetStage()->GetTargetLight(0);
    cb1.LightDir = PtrLight->GetDirectional();
    cb1.LightDir.w = 1.0f;
    Matrix4X4 LightView, LightProj, LightViewProj;
    Vector3 LightDir = -1.0 * PtrLight->GetDirectional();
    Vector3 LightAt = PtrCamera->GetAt();
    Vector3 LightEye = LightDir;
    LightEye *= Shadowmap::GetLightHeight();
    LightEye = LightAt + LightEye;

    //ライトのビューと射影を計算
    LightView.LookAtLH(LightEye, LightAt, Vector3(0, 1.0f, 0));
    LightProj.OrthographicLH(Shadowmap::GetViewWidth(), Shadowmap::GetViewHeight(),
        Shadowmap::GetLightNear(), Shadowmap::GetLightFar());
    LightViewProj = LightView * LightProj;
    Matrix4X4 LWMatrix = PtrT->GetWorldMatrix() * LightViewProj;
    //コンスタントバッファに設定
    cb1.LPos = LightEye;
    cb1.LPos.w = 0;
    cb1.EyePos = PtrCamera->GetEye();
    cb1.EyePos.w = 0;
    cb1.LView = Matrix4X4EX::Transpose(LightView);
    cb1.LProjection = Matrix4X4EX::Transpose(LightProj);

    //コンスタントバッファの更新
    pID3D11DeviceContext->UpdateSubresource(
        CBInstance::GetPtr()->GetBuffer(), 0, nullptr, &cb1, 0, 0);
    //ストライドとオフセット
    <span class="red">//形状の頂点バッファと行列バッファを設定
    UINT stride[2] = { sizeof(VertexPositionNormalTexture), sizeof(Matrix4X4) };
    UINT offset[2] = { 0, 0 };
    ID3D11Buffer* pBuf[2] = { MeshRes->GetVertexBuffer().Get(), m_MatrixBuffer.Get() };
    pID3D11DeviceContext->IASetVertexBuffers(0, 2, pBuf, stride, offset);</span>
    //インデックスバッファのセット
    pID3D11DeviceContext->IASetIndexBuffer(
        MeshRes->GetIndexBuffer().Get(), DXGI_FORMAT_R16_UINT, 0);
    //描画方法（3角形）
    pID3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    //ステータスのポインタ
    //テクスチャを取得
    ID3D11ShaderResourceView* pNull[1] = { 0 };
    ID3D11SamplerState* pNullSR[1] = { 0 };
    //テクスチャを設定
    auto PtrTextureResource = App::GetApp()->GetResource&lt;TextureResource>(m_TextureKey);
    pID3D11DeviceContext->PSSetShaderResources(
        0, 1, PtrTextureResource->GetShaderResourceView().GetAddressOf());
    //リニアサンプラーを設定
    ID3D11SamplerState* samplerState = RenderStatePtr->GetLinearClamp();
    pID3D11DeviceContext->PSSetSamplers(0, 1, &samplerState);


    //シャドウマップのリソースビューを取得
    ID3D11ShaderResourceView* pShadowSRV = ShadoumapPtr->GetShaderResourceView();
    pID3D11DeviceContext->PSSetShaderResources(1, 1, &pShadowSRV);
    //シャドウ用にリニアサンプラーを取得
    ID3D11SamplerState* pShadowSamplerState = RenderStatePtr->GetLinearClamp();
    //シャドウ用リニアサンプラーを設定
    pID3D11DeviceContext->PSSetSamplers(1, 1, &pShadowSamplerState);


    //デプスステンシルは使用する
    pID3D11DeviceContext->OMSetDepthStencilState(RenderStatePtr->GetDepthDefault(), 0);
    //シェーダの設定
    pID3D11DeviceContext->VSSetShader(VSInstance::GetPtr()->GetShader(), nullptr, 0);
    pID3D11DeviceContext->PSSetShader(PSInstance::GetPtr()->GetShader(), nullptr, 0);
    //インプットレイアウトの設定
    pID3D11DeviceContext->IASetInputLayout(VSInstance::GetPtr()->GetInputLayout());
    //コンスタントバッファの設定
    ID3D11Buffer* pConstantBuffer = CBInstance::GetPtr()->GetBuffer();
    pID3D11DeviceContext->VSSetConstantBuffers(0, 1, &pConstantBuffer);
    pID3D11DeviceContext->PSSetConstantBuffers(0, 1, &pConstantBuffer);
    //レンダリングステート
    pID3D11DeviceContext->RSSetState(RenderStatePtr->GetCullBack());
    <span class="red">//インスタンス描画(インスタンス配列の数だけ描画)
    pID3D11DeviceContext->DrawIndexedInstanced(
        MeshRes->GetNumIndicis(), 
        m_InstanceVec.size(), 0, 0, 0);</span>
    //後始末
    Dev->InitializeStates(RenderStatePtr);
    //インスタンス配列が増減する可能性があるので配列をクリア
    m_InstanceVec.clear();
}
</pre>
</div>
　赤くなっているところは、<b>インスタンス描画ならでは</b>の処理です。
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="40_09.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
